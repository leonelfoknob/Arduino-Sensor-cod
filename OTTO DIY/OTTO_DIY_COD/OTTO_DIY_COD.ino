

Platform
Découvrir
Prix
se connecter
S'inscrire


Collaborate on CAD files, with anyone.
Experience the easiet way to share, review and discuss CAD files with colleagues, clients and suppliers, and make better decisions faster.

Apprendre encore plus
Otto DIY
by 
+OttoDIY
Fork0Collectionner34Suivre386
Vue d'ensemble
dossiers
Problèmes1
Toutes le contributions / #e5e7971
Arduino codes
Contribué par | over 2 years ago
No description provided.
Aucune description fournie.
Fichiers mis à jour (1)

README.md
1
# Otto DIY
2
​
3
**Background information:**
4
​
5
•
6
​
7
Otto is truly Opensource; it means the hardware is easily discerned so that others can make it, Arduino compatible, 3D printable and customizable, the perfect opportunity to build and have your very first robot, learn robotics and have fun, you will learn the logical connection between code and action, and by assembling it, you will understand how its components and electronics work. Visit www.ottodiy.com for more detailed info.
8
​
9
•
10
​
11
### **Build Your Own Robot**
12
​
13
> ### Otto DIY can be made with [Builder Kit \(full with 3D printed parts\)](https://ottodiy.ecwid.com/Otto-DIY-Builder-Kit-p135022769)  and [Maker Kit \(only electronics\)](https://ottodiy.ecwid.com/Otto-DIY-Maker-Kit-p135022782) or create your own project with this open source content.
14
​
15
## How it Works
16
​
17
@[youtube](https://youtube.com/embed/VD6sgTo6NOY)
18
​
19
•
20
​
21
### Otto walks, dances, makes sounds and avoids obstacles, easy to program and expand or customize by your own.
22
​
23
![undefined](https://alpha.wikifactory.com/files/RmlsZTo0NDg5)
24
​
25
•
26
​
27
•
28
​
29
## Part List
30
​
31
Here there is a list of the materials you will need to build Otto.
32
​
33
![image](https://wikifactory.com/files/RmlsZToyMDY4NDY%3D)
34
​
35
* 1 x Nano ATmega328
36
* 1 x Nano I/O shield
37
* 1 x USB-A to Mini-USB Cable
38
* 1 x Ultrasound sensor HC-SR04 
39
* 4 x Micro servo SG90 9g
40
* 1 x Piezo Buzzer
41
* 6 x Female/Female Dupont Wires
42
* 1 x AAbattery holder 
43
* 4 x AA Batteries Alkaline \(must be new or have 1.5V each\)
44
* 1 x Micro Switch Self lock On/Off 8x8mm 
45
* 1 x Small Phillips screwdriver
46
* **3D printed head**
47
* **3D printed body**
48
* **3D printed leg x2**
49
* **3D printed foot x2** 
50
​
51
•
52
​
53
## 3D Printing
54
​
55
If you bought a **Builder kit** you can skip ahead but if you have the **Maker kit** you have to[ 3D print the parts ](https://wikifactory.com/+OttoDIY/otto-diy/files/3Dprint)but Otto is very well designed for 3D printing, so wont give you trouble if you follow this common parameters:
56
​
57
* Recommended to use a FDM 3D printer with PLA material.
58
* No need supports or rafts.
59
* Resolution: 0.20mm
60
* Fill density 20%
61
​
62
•
63
​
64
it should take around **8 hours to 3D print** a full set of parts for one Otto.
65
​
66
## Software
67
​
68
For coding beginners is recommended to use Mblock.
69
​
70
•
71
​
72
Download [mblock3](http://www.mblock.cc/mblock-software/) a visual programming software \(make sure to use mblock version 3\). and install our extension by just following our video bellow.
73
​
74
@[youtube](https://youtube.com/embed/je9Dnx9YIxU)
75
​
76
•
77
​
78
Connect your Arduino Nano through USB and if your computer did not recognize the USB device you should install the driver CH340 for your Operative System find it here:
79
​
80
https://sparks.gogo.co.nz/ch340.html
81
​
82
•
83
​
84
For more advanced coding and to try more advanced Otto commands you can download[ Arduino IDE \(version 1.8.5\) https://www.arduino.cc/en/Main/OldSoftwareReleases#previous](https://www.arduino.cc/en/Main/OldSoftwareReleases#previous)
85
​
86
## Electronics
87
​
88
### **Before inserting the AA batteries you should check the your connections and test your robot with the USB cable connected to a computer.**
89
​
90
### Testing the electronics
91
​
92
As a good practice you should check your electronics and software in your computer, before assembling all robot to avoid having to disassemble the whole robot to fix something:
93
​
94
1. Have Install the mBlock3 or Arduino IDE software.
95
2. Download all the libraries from the files tab and move to C:\Users\user\Documents\Arduino\libraries \(or wherever your libraries folder was installed\)
96
3. Connect your Arduino Nano through USB make sure the **driver CH340** is installed in your computer
97
   .
98
​
99
•
100
​
101
•
102
​
103
## Assembly Instructions
104
​
105
Gather all the off the shelf hardware parts that you'll need for this assembly, or start with our full kits which come with all parts needed. Kits available from www.ottodiy.com
106
​
107
•
108
​
109
Before getting started with the assembly, **download and read carefully** the [PDFs from the instruction manuals files tab folder.](https://wikifactory.com/+OttoDIY/otto-diy/files/Instruction%20manual)
110
​
111
•
112
​
113
If you do not understand something in the manual you can just follow this non-stop video of how to build Otto in less than 30min including uploading a code.
114
​
115
@[youtube](https://youtube.com/embed/8R6thwyIeb8)
116
​
117
•
118
​
119
![image](https://wikifactory.com/files/RmlsZToyMjcwNTg%3D)
120
​
121
•
122
​
123
## Customize 3D
124
​
125
Download, print, cut and make papercrafts of Otto to personalize your robot.
126
​
127
https://wikifactory.com/+OttoDIY/otto-diy/files/Papercraft
128
​
129
•
130
​
131
Otto is design using [TinkerCAD 3D software ](https://www.tinkercad.com/users/h8O1zJQboeH-camilo-parra-palacio) for FREE!, you can modify it for customization or further improvements!
132
​
133
•
134
​
135
![image](https://wikifactory.com/files/RmlsZToyNDE2NzM%3D)
136
​
137
Read this blog post to learn more of how to redesign your own robot [https://www.ottodiy.com/blog/design](https://www.ottodiy.com/blog/design)•
138
​
139
## Join the Otto builder community!
140
​
141
Follow us, subscribe, give us a like and share your creativity.
142
​
143
•
144
​
145
1. [Join us here in Wikifactory](https://wikifactory.com/invite/SW52aXRlTGluazoyMA/y3FSSTdwlvXk1KcSuFHExd5FpbREp95dgIGcIudH51M) [](https://www.youtube.com/c/ottodiy?sub_confirmation=1)& check our [Forum](https://wikifactory.com/+OttoDIY/forum) for questions.
146
2. [Group in Facebook](https://www.facebook.com/groups/ottodiy/). to share and ask for help in the community and like our [Facebook page](https://www.facebook.com/ottodiy/) 
147
3. [YouTube channel](https://www.youtube.com/c/ottodiy?sub_confirmation=1) for more how to videios and tutorials.
148
4. [Instagram](https://www.instagram.com/ottodiy/) to share \#ottodiy
149
5. [Twitter](https://twitter.com/ottodiy) to share \#ottodiy
150
​
151
•
152
​
153
You could be featured here by share your robot in any social media; Just use the hashtag \#ottodiy in your post and tag or mention +OttoDIY
154
​
155
•
156
​
157
Be a part of this friendly community of robot builders, teachers and makers!
158
​
159
•
160
​
161
Welcome to our Otto Builder community!
162
​
163
## License CC-BY-SA
164
​
165
Otto DIY by www.ottodiy.com is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.
166
​
167
•
168
​
169
You can use all resources of Otto for free but Otto DIY Website must be included in any redistribution and remixes must keep the CC-BY-SA license, As you might seen with the original Otto DIY project the idea is that more people can have access, therefore if you copy or remix Otto you must also release under same open license, that means you must release all files also to the public.
UPDATED
Fichiers renommés (18)

Code/Otto_Alarm.ino
1
//----------------------------------------------------------------
2
//-- Otto ALARM
3
//-- This code allows Otto to detect intruders with the ultrasound and alert with the buzzer
4
//-- April 2019: Designed to work with the basic Otto but could be compatible with PLUS or Humanoid or other biped robots
5
/****************************************************************************************************** 
6
  Make sure to have installed all libraries: https://wikifactory.com/+OttoDIY/otto-diy
7
  Otto DIY invests time and resources providing open source code and hardware, 
8
  please support by purchasing kits from (https://www.ottodiy.com)
9
  
10
  BSD license, all text above must be included in any redistribution
11
 *******************************************************************/
12
//-----------------------------------------------------------------
13
#include <Servo.h>
14
#include <Oscillator.h>
15
#include <EEPROM.h>
16
#include <US.h>
17
#include <Otto.h>
18
Otto Otto;  //This is Otto!!
19
//---------------------------------------------------------
20
//-- Make sure the servos are in the right pin
21
/*             -------- 
22
              |  O  O  |
23
              |--------|
24
  RIGHT LEG 3 |        | LEFT LEG 2
25
               -------- 
26
               ||     ||
27
RIGHT FOOT 5 |---     ---| LEFT FOOT 4     
28
*/
29
  #define PIN_LEFTLEG 2 //servo[2]
30
  #define PIN_RIGHTLEG 3 //servo[3]
31
  #define PIN_LEFTFOOT 4 //servo[4]
32
  #define PIN_RIGHTFOOT 5 //servo[5]
33
///////////////////////////////////////////////////////////////////
34
//-- Global Variables -------------------------------------------//
35
///////////////////////////////////////////////////////////////////
36
//-- Movement parameters
37
int T = 1000;            //Initial duration of movement
38
int moveId = 0;          //Number of movement
39
int moveSize = 15;       //Asociated with the height of some movements
40
//---------------------------------------------------------
41
bool alarmActivated = false;
42
int initDistance = 999;
43
unsigned long previousMillis = 0;
44
///////////////////////////////////////////////////////////////////
45
//-- Setup ------------------------------------------------------//
46
///////////////////////////////////////////////////////////////////
47
void setup() {
48
  Serial.begin(57600); //Serial communication initialization
49
  Otto.init(PIN_LEFTLEG, PIN_RIGHTLEG, PIN_LEFTFOOT, PIN_RIGHTFOOT, true);   //Set the servo pins
50
  //Uncomment this to set the servo trims manually and save on EEPROM
51
  //Otto.setTrims(TRIM_YL, TRIM_YR, TRIM_RL, TRIM_RR);
52
  //Otto.saveTrimsOnEEPROM(); //Uncomment this only for one upload when you finaly set the trims.
53
  Otto.sing(S_connection); //Otto wake up!
54
  Otto.home();
55
  delay(50);
56
}
57
///////////////////////////////////////////////////////////////////
58
//-- Principal Loop ---------------------------------------------//
59
///////////////////////////////////////////////////////////////////
60
void loop() {      
61
        if (alarmActivated == false) {  //Arming alarm system
62
          Otto.ascendingTurn(2, 1000, 50);
63
          OttoArmingAlarmSystem();
64
 }
65
 else {
66
  delay(100);
67
          //ALARM!!!!
68
          if (Otto.getDistance() < initDistance) {
69
            delay(50);
70
              Otto.bendTones (note_A5, note_A7, 1.04, 5, 2);  //A5 = 880 , A7 = 3520
71
              delay(20);
72
              Otto.bendTones (note_A7, note_A5, 1.02, 5, 2);  //A5 = 880 , A7 = 3520
73
              delay(100);
74
         }
75
 }
76
}
77
void OttoArmingAlarmSystem() {
78
​
79
  int countDown = 10000; //10 sec
80
  while (countDown > 0) {
81
    countDown -= 1000;
82
    Otto._tone(note_A7, 50, 0); //bip'
83
    delay(300);
84
    delay(650);
85
  }
86
    alarmActivated = true;
87
    delay(100);
88
    initDistance = Otto.getDistance();
89
    delay(100);
90
    initDistance -= 10;
91
    previousMillis = millis();
92
}
93
​
RENAMED
Code/Otto_Footalign.ino
1
//----------------------------------------------------------------
2
//-- Otto Foot align
3
//-- This code will make the servo motors to find the ZERO position for assembly
4
//-- April 2019: Designed to work with the basic Otto but could be compatible with PLUS or Humanoid or other biped robots
5
/******************************************************************************************************
6
  Make sure to have installed all libraries: https://wikifactory.com/+OttoDIY/otto-diy
7
  Otto DIY invests time and resources providing open source code and hardware, 
8
  please support by purchasing kits from (https://www.ottodiy.com)
9
  
10
  BSD license, all text above must be included in any redistribution
11
 *******************************************************************/
12
//-----------------------------------------------------------------
13
#include <Servo.h>
14
//-- First step: Configure the pins where the servos are attached
15
/*
16
         --------------- 
17
        |     O   O     |
18
        |---------------|
19
YR 3==> |               | <== YL 2
20
         --------------- 
21
            ||     ||
22
            ||     ||
23
RR 5==>   -----   ------  <== RL 4
24
         |-----   ------|
25
*/
26
​
27
Servo YL_Servo;  // create servo object to control a YL 2
28
Servo YR_Servo;  // create servo object to control a YR 3
29
Servo RL_Servo;  // create servo object to control a RL 4
30
Servo RR_Servo;  // create servo object to control a RR 5
31
​
32
int minim = 10;
33
int maxim = 170;
34
​
35
void setup() {
36
  YL_Servo.attach(2);  // attaches the servo on pin 2 to the servo object 1
37
  YR_Servo.attach(3);  // attaches the servo on pin 3 to the servo object 2 
38
  RL_Servo.attach(4);  // attaches the servo on pin 4 to the servo object 3
39
  RR_Servo.attach(5);  // attaches the servo on pin 5 to the servo object 4 
40
​
41
  YL_Servo.write(minim);                  // sets the servo 1 position 
42
  YR_Servo.write(minim);                  // sets the servo 2 position
43
  RL_Servo.write(minim);                  // sets the servo 3 position 
44
  RR_Servo.write(minim);                  // sets the servo 4 position
45
delay(3000);
46
  YL_Servo.write(maxim);                  // sets the servo 1 position 
47
  YR_Servo.write(maxim);                  // sets the servo 2 position
48
  RL_Servo.write(maxim);                  // sets the servo 3 position 
49
  RR_Servo.write(maxim);                  // sets the servo 4 position
50
delay(3000);
51
}
52
​
53
void loop() {
54
  YL_Servo.write(90);                  // sets the servo 1 position 
55
  YR_Servo.write(90);                  // sets the servo 2 position
56
  RL_Servo.write(90);                  // sets the servo 3 position 
57
  RR_Servo.write(90);                  // sets the servo 4 position
58
}
59
​
RENAMED
Code/Otto_MarioBros.ino
1
/*Arduino Mario Bros Tunes
2
  With Piezo Buzzer and PWM
3
 Connect the positive side of the Buzzer to pin 13,
4
  by: Dipto Pratyaksa
5
  adapted to ottodiy.com
6
*/
7
 
8
/*************************************************
9
 * Public Constants
10
 *************************************************/
11
 
12
#define NOTE_B0  31
13
#define NOTE_C1  33
14
#define NOTE_CS1 35
15
#define NOTE_D1  37
16
#define NOTE_DS1 39
17
#define NOTE_E1  41
18
#define NOTE_F1  44
19
#define NOTE_FS1 46
20
#define NOTE_G1  49
21
#define NOTE_GS1 52
22
#define NOTE_A1  55
23
#define NOTE_AS1 58
24
#define NOTE_B1  62
25
#define NOTE_C2  65
26
#define NOTE_CS2 69
27
#define NOTE_D2  73
28
#define NOTE_DS2 78
29
#define NOTE_E2  82
30
#define NOTE_F2  87
31
#define NOTE_FS2 93
32
#define NOTE_G2  98
33
#define NOTE_GS2 104
34
#define NOTE_A2  110
35
#define NOTE_AS2 117
36
#define NOTE_B2  123
37
#define NOTE_C3  131
38
#define NOTE_CS3 139
39
#define NOTE_D3  147
40
#define NOTE_DS3 156
41
#define NOTE_E3  165
42
#define NOTE_F3  175
43
#define NOTE_FS3 185
44
#define NOTE_G3  196
45
#define NOTE_GS3 208
46
#define NOTE_A3  220
47
#define NOTE_AS3 233
48
#define NOTE_B3  247
49
#define NOTE_C4  262
50
#define NOTE_CS4 277
51
#define NOTE_D4  294
52
#define NOTE_DS4 311
53
#define NOTE_E4  330
54
#define NOTE_F4  349
55
#define NOTE_FS4 370
56
#define NOTE_G4  392
57
#define NOTE_GS4 415
58
#define NOTE_A4  440
59
#define NOTE_AS4 466
60
#define NOTE_B4  494
61
#define NOTE_C5  523
62
#define NOTE_CS5 554
63
#define NOTE_D5  587
64
#define NOTE_DS5 622
65
#define NOTE_E5  659
66
#define NOTE_F5  698
67
#define NOTE_FS5 740
68
#define NOTE_G5  784
69
#define NOTE_GS5 831
70
#define NOTE_A5  880
71
#define NOTE_AS5 932
72
#define NOTE_B5  988
73
#define NOTE_C6  1047
74
#define NOTE_CS6 1109
75
#define NOTE_D6  1175
76
#define NOTE_DS6 1245
77
#define NOTE_E6  1319
78
#define NOTE_F6  1397
79
#define NOTE_FS6 1480
80
#define NOTE_G6  1568
81
#define NOTE_GS6 1661
82
#define NOTE_A6  1760
83
#define NOTE_AS6 1865
84
#define NOTE_B6  1976
85
#define NOTE_C7  2093
86
#define NOTE_CS7 2217
87
#define NOTE_D7  2349
88
#define NOTE_DS7 2489
89
#define NOTE_E7  2637
90
#define NOTE_F7  2794
91
#define NOTE_FS7 2960
92
#define NOTE_G7  3136
93
#define NOTE_GS7 3322
94
#define NOTE_A7  3520
95
#define NOTE_AS7 3729
96
#define NOTE_B7  3951
97
#define NOTE_C8  4186
98
#define NOTE_CS8 4435
99
#define NOTE_D8  4699
100
#define NOTE_DS8 4978
101
 
102
#define melodyPin 13
103
//Mario main theme melody
104
int melody[] = {
105
  NOTE_E7, NOTE_E7, 0, NOTE_E7,
106
  0, NOTE_C7, NOTE_E7, 0,
107
  NOTE_G7, 0, 0,  0,
108
  NOTE_G6, 0, 0, 0,
109
 
110
  NOTE_C7, 0, 0, NOTE_G6,
111
  0, 0, NOTE_E6, 0,
112
  0, NOTE_A6, 0, NOTE_B6,
113
  0, NOTE_AS6, NOTE_A6, 0,
114
 
115
  NOTE_G6, NOTE_E7, NOTE_G7,
116
  NOTE_A7, 0, NOTE_F7, NOTE_G7,
117
  0, NOTE_E7, 0, NOTE_C7,
118
  NOTE_D7, NOTE_B6, 0, 0,
119
 
120
  NOTE_C7, 0, 0, NOTE_G6,
121
  0, 0, NOTE_E6, 0,
122
  0, NOTE_A6, 0, NOTE_B6,
123
  0, NOTE_AS6, NOTE_A6, 0,
124
 
125
  NOTE_G6, NOTE_E7, NOTE_G7,
126
  NOTE_A7, 0, NOTE_F7, NOTE_G7,
127
  0, NOTE_E7, 0, NOTE_C7,
128
  NOTE_D7, NOTE_B6, 0, 0
129
};
130
//Mario main them tempo
131
int tempo[] = {
132
  12, 12, 12, 12,
133
  12, 12, 12, 12,
134
  12, 12, 12, 12,
135
  12, 12, 12, 12,
136
 
137
  12, 12, 12, 12,
138
  12, 12, 12, 12,
139
  12, 12, 12, 12,
140
  12, 12, 12, 12,
141
 
142
  9, 9, 9,
143
  12, 12, 12, 12,
144
  12, 12, 12, 12,
145
  12, 12, 12, 12,
146
 
147
  12, 12, 12, 12,
148
  12, 12, 12, 12,
149
  12, 12, 12, 12,
150
  12, 12, 12, 12,
151
 
152
  9, 9, 9,
153
  12, 12, 12, 12,
154
  12, 12, 12, 12,
155
  12, 12, 12, 12,
156
};
157
//Underworld melody
158
int underworld_melody[] = {
159
  NOTE_C4, NOTE_C5, NOTE_A3, NOTE_A4,
160
  NOTE_AS3, NOTE_AS4, 0,
161
  0,
162
  NOTE_C4, NOTE_C5, NOTE_A3, NOTE_A4,
163
  NOTE_AS3, NOTE_AS4, 0,
164
  0,
165
  NOTE_F3, NOTE_F4, NOTE_D3, NOTE_D4,
166
  NOTE_DS3, NOTE_DS4, 0,
167
  0,
168
  NOTE_F3, NOTE_F4, NOTE_D3, NOTE_D4,
169
  NOTE_DS3, NOTE_DS4, 0,
170
  0, NOTE_DS4, NOTE_CS4, NOTE_D4,
171
  NOTE_CS4, NOTE_DS4,
172
  NOTE_DS4, NOTE_GS3,
173
  NOTE_G3, NOTE_CS4,
174
  NOTE_C4, NOTE_FS4, NOTE_F4, NOTE_E3, NOTE_AS4, NOTE_A4,
175
  NOTE_GS4, NOTE_DS4, NOTE_B3,
176
  NOTE_AS3, NOTE_A3, NOTE_GS3,
177
  0, 0, 0
178
};
179
//Underwolrd tempo
180
int underworld_tempo[] = {
181
  12, 12, 12, 12,
182
  12, 12, 6,
183
  3,
184
  12, 12, 12, 12,
185
  12, 12, 6,
186
  3,
187
  12, 12, 12, 12,
188
  12, 12, 6,
189
  3,
190
  12, 12, 12, 12,
191
  12, 12, 6,
192
  6, 18, 18, 18,
193
  6, 6,
194
  6, 6,
195
  6, 6,
196
  18, 18, 18, 18, 18, 18,
197
  10, 10, 10,
198
  10, 10, 10,
199
  3, 3, 3
200
};
201
 
202
void setup(void)
203
{
204
  pinMode(13, OUTPUT);//buzzer
205
  pinMode(10, OUTPUT);//led indicator when singing a note
206
 
207
}
208
void loop()
209
{
210
  //sing the tunes
211
  sing(1);
212
  sing(1);
213
  sing(2);
214
}
215
int song = 0;
216
 
217
void sing(int s) {
218
  // iterate over the notes of the melody:
219
  song = s;
220
  if (song == 2) {
221
    Serial.println(" 'Underworld Theme'");
222
    int size = sizeof(underworld_melody) / sizeof(int);
223
    for (int thisNote = 0; thisNote < size; thisNote++) {
224
 
225
      // to calculate the note duration, take one second
226
      // divided by the note type.
227
      //e.g. quarter note = 1000 / 4, eighth note = 1000/8, etc.
228
      int noteDuration = 1000 / underworld_tempo[thisNote];
229
 
230
      buzz(melodyPin, underworld_melody[thisNote], noteDuration);
231
 
232
      // to distinguish the notes, set a minimum time between them.
233
      // the note's duration + 30% seems to work well:
234
      int pauseBetweenNotes = noteDuration * 1.30;
235
      delay(pauseBetweenNotes);
236
 
237
      // stop the tone playing:
238
      buzz(melodyPin, 0, noteDuration);
239
 
240
    }
241
 
242
  } else {
243
 
244
    Serial.println(" 'Mario Theme'");
245
    int size = sizeof(melody) / sizeof(int);
246
    for (int thisNote = 0; thisNote < size; thisNote++) {
247
 
248
      // to calculate the note duration, take one second
249
      // divided by the note type.
250
      //e.g. quarter note = 1000 / 4, eighth note = 1000/8, etc.
251
      int noteDuration = 1000 / tempo[thisNote];
252
 
253
      buzz(melodyPin, melody[thisNote], noteDuration);
254
 
255
      // to distinguish the notes, set a minimum time between them.
256
      // the note's duration + 30% seems to work well:
257
      int pauseBetweenNotes = noteDuration * 1.30;
258
      delay(pauseBetweenNotes);
259
 
260
      // stop the tone playing:
261
      buzz(melodyPin, 0, noteDuration);
262
 
263
    }
264
  }
265
}
266
 
267
void buzz(int targetPin, long frequency, long length) {
268
  digitalWrite(10, HIGH);
269
  long delayValue = 1000000 / frequency / 2; // calculate the delay value between transitions
270
  //// 1 second's worth of microseconds, divided by the frequency, then split in half since
271
  //// there are two phases to each cycle
272
  long numCycles = frequency * length / 1000; // calculate the number of cycles for proper timing
273
  //// multiply frequency, which is really cycles per second, by the number of seconds to
274
  //// get the total number of cycles to produce
275
  for (long i = 0; i < numCycles; i++) { // for the calculated length of time...
276
    digitalWrite(targetPin, HIGH); // write the buzzer pin high to push out the diaphram
277
    delayMicroseconds(delayValue); // wait for the calculated delay value
278
    digitalWrite(targetPin, LOW); // write the buzzer pin low to pull back the diaphram
279
    delayMicroseconds(delayValue); // wait again or the calculated delay value
280
  }
281
  digitalWrite(10, LOW);
282
 
283
}
284
​
RENAMED
Code/Otto_Mblock_Scratch_Serial.ino
1
//----------------------------------------------------------------
2
// Otto mBlock Software in Scratch Mode via USBSerial Cable
3
//-- With this code Otto can be control via serial with your computer by connecting Otto with cable USB using mblock or scratch, choose right SerialPort and Arduino Nano 328 as board
4
//-- April 2019: Designed to work with the basic Otto but could be compatible with PLUS or Humanoid or other biped robots
5
/******************************************************************************************************
6
  Make sure to have installed all libraries: https://wikifactory.com/+OttoDIY/otto-diy
7
  Otto DIY invests time and resources providing open source code and hardware, 
8
  please support by purchasing kits from (https://www.ottodiy.com)
9
  
10
  BSD license, all text above must be included in any redistribution
11
 *******************************************************************/
12
//-----------------------------------------------------------------
13
#include "Otto.h"
14
#include "OttoSerialCommand.h"
15
OttoSerialCommand SCmd; //The SerialCommand object
16
//---------------------------------------------------------
17
//-- Make sure the servos are in the right pin
18
/*             -------- 
19
              |  O  O  |
20
              |--------|
21
  RIGHT LEG 3 |        | LEFT LEG 2
22
               -------- 
23
               ||     ||
24
RIGHT FOOT 5 |---     ---| LEFT FOOT 4 
25
*/
26
Otto Otto;  
27
//---------------------------------------------------------
28
#define PIN_LEFT_LEG   2   
29
#define PIN_RIGHT_LEG  3  
30
#define PIN_LEFT_FOOT  4  
31
#define PIN_RIGHT_FOOT 5 
32
//---------------------------------------------------------
33
///////////////////////////////////////////////////////////////////
34
//-- Global Variables -------------------------------------------//
35
///////////////////////////////////////////////////////////////////
36
const char programID[]="Otto_mBlock";
37
const char name_fac='$'; //Factory name
38
const char name_fir='#'; 
39
​
40
//-- Movement parameters
41
int T=1000;              //Initial duration of movement, show the speed
42
int moveId=0;            //Type of movement
43
int moveSize=15;         //Size of movement
44
unsigned long previousMillis=0;
45
int randomDance=0;
46
int randomSteps=0;
47
bool obstacleDetected = false;
48
///////////////////////////////////////////////////////////////////
49
//-- Setup ------------------------------------------------------//
50
///////////////////////////////////////////////////////////////////
51
void setup(){
52
​
53
  //BT.begin(9600);  
54
  Serial.begin(115200);
55
  Otto.init(PIN_LEFT_LEG,PIN_RIGHT_LEG,PIN_LEFT_FOOT,PIN_RIGHT_FOOT, false, PIN_NoiseSensor, PIN_Buzzer,PIN_Echo, PIN_Trigger);  
56
  randomSeed(analogRead(A0));
57
  SCmd.addCommand("S", receiveStop);      //  sendAck & sendFinalAck
58
  SCmd.addCommand("L", receiveLED);       //  sendAck & sendFinalAck
59
  SCmd.addCommand("T", recieveBuzzer);    //  sendAck & sendFinalAck
60
  SCmd.addCommand("M", receiveMovement);  //  sendAck & sendFinalAck
61
  SCmd.addCommand("H", receiveGesture);   //  sendAck & sendFinalAck
62
  SCmd.addCommand("K", receiveSing);      //  sendAck & sendFinalAck
63
  SCmd.addCommand("C", receiveTrims);     //  sendAck & sendFinalAck
64
  SCmd.addCommand("G", receiveServo);     //  sendAck & sendFinalAck
65
  SCmd.addCommand("R", receiveName);      //  sendAck & sendFinalAck
66
  SCmd.addCommand("E", requestName);
67
  SCmd.addCommand("D", requestDistance);
68
  SCmd.addCommand("N", requestNoise);
69
  SCmd.addCommand("B", requestBattery);
70
  SCmd.addCommand("I", requestProgramId);
71
  SCmd.addDefaultHandler(receiveStop);
72
  
73
  Otto.sing(S_connection);
74
  Otto.home();
75
  delay(50);
76
  requestName();
77
  delay(50);
78
  requestProgramId();
79
  delay(50);
80
  requestBattery();
81
​
82
  LowBatteryAlarm();
83
  Otto.sing(S_happy);
84
  delay(200);
85
}
86
​
87
///////////////////////////////////////////////////////////////////
88
//-- Principal Loop ---------------------------------------------//
89
///////////////////////////////////////////////////////////////////
90
void loop() {
91
​
92
  if (Serial.available() > 0) {
93
​
94
    SCmd.readSerial();
95
  
96
    //If is moving yet
97
    if (Otto.getRestState()==false) {
98
      move(moveId);
99
    }
100
  } 
101
}
102
​
103
///////////////////////////////////////////////////////////////////
104
//-- Functions --------------------------------------------------//
105
///////////////////////////////////////////////////////////////////
106
void obstacleDetector(){
107
​
108
   int distance = Otto.getDistance();
109
​
110
        if(distance<15){
111
          obstacleDetected = true;
112
        }else{
113
          obstacleDetected = false;
114
        }
115
}
116
//-- Function to receive Stop command.
117
void receiveStop(){
118
    sendAck();
119
    Otto.home();
120
    sendFinalAck();
121
}
122
void receiveLED(){  
123
​
124
    //sendAck & stop if necessary
125
    sendAck();
126
    Otto.home();
127
     //put some code for deny (not available)
128
   
129
    sendFinalAck();
130
​
131
}
132
void recieveBuzzer(){
133
  
134
    //sendAck & stop if necessary
135
    sendAck();
136
    Otto.home(); 
137
​
138
    bool error = false; 
139
    int frec;
140
    int duration; 
141
    char *arg; 
142
    
143
    arg = SCmd.next(); 
144
    if (arg != NULL) { frec=atoi(arg); }    // Converts a char string to an integer   
145
    else {error=true;}
146
    
147
    arg = SCmd.next(); 
148
    if (arg != NULL) { duration=atoi(arg); } // Converts a char string to an integer  
149
    else {error=true;}
150
​
151
    if(error==true){
152
      delay(2000);
153
    }else{ 
154
      Otto._tone(frec, duration, 1);   
155
    }
156
​
157
    sendFinalAck();
158
}
159
//-- Function to receive TRims commands
160
void receiveTrims(){  
161
​
162
    //sendAck & stop if necessary
163
    sendAck();
164
    Otto.home(); 
165
    Otto.sing(S_confused);
166
    //Otto.playGesture(RobotConfused);// Indicate that Function not availabe for this version
167
}
168
 
169
//-- Function to receive Servo commands
170
void receiveServo(){  
171
​
172
    sendAck(); 
173
    moveId = 30;
174
​
175
    //Definition of Servo Bluetooth command
176
    //G  servo_YL servo_YR servo_RL servo_RR 
177
    //Example of receiveServo Bluetooth commands
178
    //G 90 85 96 78 
179
    bool error = false;
180
    char *arg;
181
    int servo_YL,servo_YR,servo_RL,servo_RR;
182
​
183
    arg=SCmd.next();
184
    if (arg != NULL) { servo_YL=atoi(arg); }    // Converts a char string to an integer   
185
    else {error=true;}
186
​
187
    arg = SCmd.next(); 
188
    if (arg != NULL) { servo_YR=atoi(arg); }    // Converts a char string to an integer  
189
    else {error=true;}
190
​
191
    arg = SCmd.next(); 
192
    if (arg != NULL) { servo_RL=atoi(arg); }    // Converts a char string to an integer  
193
    else {error=true;}
194
​
195
    arg = SCmd.next(); 
196
    if (arg != NULL) { servo_RR=atoi(arg); }    // Converts a char string to an integer  
197
    else {error=true;}
198
    
199
    if(error==true){
200
​
201
//      Otto.putMouth(xMouth);
202
      delay(2000);
203
  //    Otto.clearMouth();
204
​
205
    }else{ //Update Servo:
206
​
207
      int servoPos[4]={servo_YL, servo_YR, servo_RL, servo_RR}; 
208
      Otto._moveServos(200, servoPos);   //Move 200ms
209
      
210
    }
211
    sendFinalAck();
212
}
213
​
214
void receiveMovement(){
215
​
216
    sendAck();
217
  //  Serial.print("Move Command: ");
218
    if (Otto.getRestState()==true){
219
        Otto.setRestState(false);
220
    }
221
​
222
    //Definition of Movement Bluetooth commands
223
    //M  MoveID  T   MoveSize  
224
    char *arg; 
225
    arg = SCmd.next(); 
226
    if (arg != NULL) {moveId=atoi(arg);}// Serial.println(moveId); Serial.print(" ");}
227
    else{
228
//      Otto.putMouth(xMouth);
229
      delay(2000);
230
  //    Otto.clearMouth();
231
      moveId=0; //stop
232
    }
233
    
234
    arg = SCmd.next(); 
235
    if (arg != NULL) {T=atoi(arg);} //Serial.println(T); Serial.print(" ");}
236
    else{
237
      T=1000;
238
    }
239
​
240
    arg = SCmd.next(); 
241
    if (arg != NULL) {moveSize=atoi(arg);}// Serial.println(moveSize); Serial.print(" ");}
242
    else{
243
      moveSize =30;
244
    }
245
}
246
​
247
//-- Function to execute the right movement according the movement command received.///
248
void move(int moveId){
249
​
250
  bool manualMode = false;
251
​
252
  switch (moveId) {
253
    case 0:
254
      Otto.home();
255
      break;
256
    case 1: //M 1 1000 
257
      Otto.walk(1,T,1);
258
      break;
259
    case 2: //M 2 1000 
260
      Otto.walk(1,T,-1);
261
      break;
262
    case 3: //M 3 1000 
263
      Otto.turn(1,T,1);
264
      break;
265
    case 4: //M 4 1000 
266
      Otto.turn(1,T,-1);
267
      break;
268
    case 5: //M 5 1000 30 
269
      Otto.updown(1,T,30);
270
      break;
271
    case 6: //M 6 1000 30
272
      moveSize = 30;
273
      Otto.moonwalker(1,T,moveSize,1);
274
      break;
275
    case 7: //M 7 1000 30
276
      moveSize = 30;
277
      Otto.moonwalker(1,T,moveSize,-1);
278
      break;
279
    case 8: //M 8 1000 30
280
      moveSize =30;
281
      Otto.swing(1,T,moveSize);
282
      break;
283
    case 9: //M 9 1000 30 
284
      moveSize =30;
285
      Otto.crusaito(1,T,moveSize,1);
286
      break;
287
    case 10: //M 10 1000 30 
288
      moveSize =30;
289
      Otto.crusaito(1,T,moveSize,-1);
290
      break;
291
    case 11: //M 11 1000 
292
      Otto.jump(1,T);
293
      break;
294
    case 12: //M 12 1000 30 
295
      moveSize =30;
296
      Otto.flapping(1,T,moveSize,1);
297
      break;
298
    case 13: //M 13 1000 30
299
      moveSize =30;
300
      Otto.flapping(1,T,moveSize,-1);
301
      break;
302
    case 14: //M 14 1000 20
303
      moveSize =30;
304
      Otto.tiptoeSwing(1,T,moveSize);
305
      break;
306
    case 15: //M 15 500 
307
      Otto.bend(1,T,1);
308
      break;
309
    case 16: //M 16 500 
310
      Otto.bend(1,T,-1);
311
      break;
312
    case 17: //M 17 500 
313
      Otto.shakeLeg(1,T,1);
314
      break;
315
    case 18: //M 18 500 
316
      Otto.shakeLeg(1,T,-1);
317
      break;
318
    case 19: //M 19 500 20
319
      moveSize =30;
320
      Otto.jitter(1,T,moveSize);
321
      break;
322
    case 20: //M 20 500 15
323
      Otto.ascendingTurn(1,T,moveSize);
324
      break;
325
    default:
326
        manualMode = true;
327
      break;
328
  }
329
​
330
  if (!manualMode){
331
    sendFinalAck();
332
  }
333
       
334
}
335
​
336
//-- Function to receive gesture commands
337
void receiveGesture(){
338
​
339
    //sendAck & stop if necessary
340
    sendAck();
341
    Otto.home(); 
342
​
343
    //Definition of Gesture Bluetooth commands
344
    //H  GestureID  
345
    int gesture = 0;
346
    char *arg; 
347
    arg = SCmd.next(); 
348
    if (arg != NULL) {gesture=atoi(arg);}
349
    else 
350
    {
351
      //Otto.putMouth(xMouth);
352
      delay(2000);
353
      //Otto.clearMouth();
354
    }
355
​
356
    switch (gesture) {
357
      case 1: //H 1 
358
        Otto.playGesture(OttoHappy);
359
        break;
360
      case 2: //H 2 
361
        Otto.playGesture(OttoSuperHappy);
362
        break;
363
      case 3: //H 3 
364
        Otto.playGesture(OttoSad);
365
        break;
366
      case 4: //H 4 
367
        Otto.playGesture(OttoSleeping);
368
        break;
369
      case 5: //H 5  
370
        Otto.playGesture(OttoFart);
371
        break;
372
      case 6: //H 6 
373
        Otto.playGesture(OttoConfused);
374
        break;
375
      case 7: //H 7 
376
        Otto.playGesture(OttoLove);
377
        break;
378
      case 8: //H 8 
379
        Otto.playGesture(OttoAngry);
380
        break;
381
      case 9: //H 9  
382
        Otto.playGesture(OttoFretful);
383
        break;
384
      case 10: //H 10
385
        Otto.playGesture(OttoMagic);
386
        break;  
387
      case 11: //H 11
388
        Otto.playGesture(OttoWave);
389
        break;   
390
      case 12: //H 12
391
        Otto.playGesture(OttoVictory);
392
        break; 
393
      case 13: //H 13
394
        Otto.playGesture(OttoFail);
395
        break;         
396
      default:
397
        break;
398
    }
399
​
400
    sendFinalAck();
401
}
402
​
403
//-- Function to receive sing commands
404
void receiveSing(){
405
​
406
    //sendAck & stop if necessary
407
    sendAck();
408
    Otto.home(); 
409
​
410
    //Definition of Sing Bluetooth commands
411
    //K  SingID    
412
    int sing = 0;
413
    char *arg; 
414
    arg = SCmd.next(); 
415
    if (arg != NULL) {sing=atoi(arg);}
416
    else 
417
    {
418
     // Otto.putMouth(xMouth);
419
      delay(2000);
420
     // Otto.clearMouth();
421
    }
422
​
423
    switch (sing) {
424
      case 1: //K 1 
425
        Otto.sing(S_connection);
426
        break;
427
      case 2: //K 2 
428
        Otto.sing(S_disconnection);
429
        break;
430
      case 3: //K 3 
431
        Otto.sing(S_surprise);
432
        break;
433
      case 4: //K 4 
434
        Otto.sing(S_OhOoh);
435
        break;
436
      case 5: //K 5  
437
        Otto.sing(S_OhOoh2);
438
        break;
439
      case 6: //K 6 
440
        Otto.sing(S_cuddly);
441
        break;
442
      case 7: //K 7 
443
        Otto.sing(S_sleeping);
444
        break;
445
      case 8: //K 8 
446
        Otto.sing(S_happy);
447
        break;
448
      case 9: //K 9  
449
        Otto.sing(S_superHappy);
450
        break;
451
      case 10: //K 10
452
        Otto.sing(S_happy_short);
453
        break;  
454
      case 11: //K 11
455
        Otto.sing(S_sad);
456
        break;   
457
      case 12: //K 12
458
        Otto.sing(S_confused);
459
        break; 
460
      case 13: //K 13
461
        Otto.sing(S_fart1);
462
        break;
463
      case 14: //K 14
464
        Otto.sing(S_fart2);
465
        break;
466
      case 15: //K 15
467
        Otto.sing(S_fart3);
468
        break;    
469
      case 16: //K 16
470
        Otto.sing(S_mode1);
471
        break; 
472
      case 17: //K 17
473
        Otto.sing(S_mode2);
474
        break; 
475
      case 18: //K 18
476
        Otto.sing(S_mode3);
477
        break;   
478
      case 19: //K 19
479
        Otto.sing(S_buttonPushed);
480
        break;                      
481
      default:
482
        break;
483
    }
484
​
485
    sendFinalAck();
486
}
487
​
488
//-- Function to receive Name command
489
void receiveName(){
490
​
491
    Otto.home(); 
492
    Otto.sing(S_confused); //deny to receive command changing the name. 
493
​
494
}
495
​
496
//-- Function to send Otto's name
497
void requestName(){
498
​
499
    Otto.home(); //stop if necessary
500
​
501
    char actualOttoName[11]= "Zowi";  //Variable to store data read from EEPROM.
502
​
503
    Serial.print(F("&&"));
504
    Serial.print(F("E "));
505
    Serial.print(actualOttoName);
506
    Serial.println(F("%%"));
507
    Serial.flush();
508
}
509
​
510
//-- Function to send ultrasonic sensor measure (distance in "cm")
511
void requestDistance(){
512
​
513
    Otto.home();  //stop if necessary  
514
​
515
    int distance = Otto.getDistance();
516
    Serial.print(F("&&"));
517
    Serial.print(F("D "));
518
    Serial.print(distance);
519
    Serial.println(F("%%"));
520
    Serial.flush();
521
}
522
​
523
void requestNoise(){
524
​
525
    Otto.home();  //stop if necessary
526
​
527
    int microphone= Otto.getNoise(); //analogRead(PIN_NoiseSensor);
528
    Serial.print(F("&&"));
529
    Serial.print(F("N "));
530
    Serial.print(microphone);
531
    Serial.println(F("%%"));
532
    Serial.flush();
533
}
534
​
535
void requestBattery(){
536
​
537
    Otto.home();  //stop if necessary
538
​
539
    //The first read of the batery is often a wrong reading, so we will discard this value. 
540
    double batteryLevel = Otto.getBatteryLevel();
541
​
542
    Serial.print(F("&&"));
543
    Serial.print(F("B "));
544
    Serial.print(batteryLevel);
545
    Serial.println(F("%%"));
546
    Serial.flush();
547
}
548
​
549
void requestProgramId(){
550
​
551
    Otto.home();   //stop if necessary
552
​
553
    Serial.print(F("&&"));
554
    Serial.print(F("I "));
555
    Serial.print(programID);
556
    Serial.println(F("%%"));
557
    Serial.flush();
558
}
559
​
560
void sendAck(){
561
​
562
  delay(30);
563
​
564
  Serial.print(F("&&"));
565
  Serial.print(F("A"));
566
  Serial.println(F("%%"));
567
  Serial.flush();
568
}
569
​
570
void sendFinalAck(){
571
​
572
  delay(30);
573
​
574
  Serial.print(F("&&"));
575
  Serial.print(F("F"));
576
  Serial.println(F("%%"));
577
  Serial.flush();
578
}
579
​
580
void LowBatteryAlarm(){
581
​
582
    double batteryLevel = Otto.getBatteryLevel();
583
​
584
    if(batteryLevel<45){
585
      Otto.bendTones (880, 2000, 1.04, 8, 3);  //A5 = 880
586
      
587
      delay(30);
588
      
589
      Otto.bendTones (2000, 880, 1.02, 8, 3);  //A5 = 880
590
      delay(500);     
591
    }
592
}
593
​
RENAMED
Code/Otto_SW.ino
1
// NB: ALL NOTES DEFINED WITH STANDARD ENGLISH NAMES, EXCEPT FROM "A" 
2
//THAT IS CALLED WITH THE ITALIAN NAME "LA" BECAUSE A0,A1...ARE THE ANALOG PINS ON ARDUINO.
3
// (Ab IS CALLED Ab AND NOT LAb)
4
#define  C0 16.35
5
#define Db0 17.32
6
#define D0  18.35
7
#define Eb0 19.45
8
#define E0  20.60
9
#define F0  21.83
10
#define Gb0 23.12
11
#define G0  24.50
12
#define Ab0 25.96
13
#define LA0 27.50
14
#define Bb0 29.14
15
#define B0  30.87
16
#define C1  32.70
17
#define Db1 34.65
18
#define D1  36.71
19
#define Eb1 38.89
20
#define E1  41.20
21
#define F1  43.65
22
#define Gb1 46.25
23
#define G1  49.00
24
#define Ab1 51.91
25
#define LA1 55.00
26
#define Bb1 58.27
27
#define B1  61.74
28
#define C2  65.41
29
#define Db2 69.30
30
#define D2  73.42
31
#define Eb2 77.78
32
#define E2  82.41
33
#define F2  87.31
34
#define Gb2 92.50
35
#define G2  98.00
36
#define Ab2 103.83
37
#define LA2 110.00
38
#define Bb2 116.54
39
#define B2  123.47
40
#define C3  130.81
41
#define Db3 138.59
42
#define D3  146.83
43
#define Eb3 155.56
44
#define E3  164.81
45
#define F3  174.61
46
#define Gb3 185.00
47
#define G3  196.00
48
#define Ab3 207.65
49
#define LA3 220.00
50
#define Bb3 233.08
51
#define B3  246.94
52
#define C4  261.63
53
#define Db4 277.18
54
#define D4  293.66
55
#define Eb4 311.13
56
#define E4  329.63
57
#define F4  349.23
58
#define Gb4 369.99
59
#define G4  392.00
60
#define Ab4 415.30
61
#define LA4 440.00
62
#define Bb4 466.16
63
#define B4  493.88
64
#define C5  523.25
65
#define Db5 554.37
66
#define D5  587.33
67
#define Eb5 622.25
68
#define E5  659.26
69
#define F5  698.46
70
#define Gb5 739.99
71
#define G5  783.99
72
#define Ab5 830.61
73
#define LA5 880.00
74
#define Bb5 932.33
75
#define B5  987.77
76
#define C6  1046.50
77
#define Db6 1108.73
78
#define D6  1174.66
79
#define Eb6 1244.51
80
#define E6  1318.51
81
#define F6  1396.91
82
#define Gb6 1479.98
83
#define G6  1567.98
84
#define Ab6 1661.22
85
#define LA6 1760.00
86
#define Bb6 1864.66
87
#define B6  1975.53
88
#define C7  2093.00
89
#define Db7 2217.46
90
#define D7  2349.32
91
#define Eb7 2489.02
92
#define E7  2637.02
93
#define F7  2793.83
94
#define Gb7 2959.96
95
#define G7  3135.96
96
#define Ab7 3322.44
97
#define LA7 3520.01
98
#define Bb7 3729.31
99
#define B7  3951.07
100
#define C8  4186.01
101
#define Db8 4434.92
102
#define D8  4698.64
103
#define Eb8 4978.03
104
// DURATION OF THE NOTES 
105
#define BPM 120    //  you can change this value changing all the others
106
#define H 2*Q //half 2/4
107
#define Q 60000/BPM //quarter 1/4 
108
#define E Q/2   //eighth 1/8
109
#define S Q/4 // sixteenth 1/16
110
#define W 4*Q // whole 4/4
111
​
112
void setup() {     
113
pinMode(13, OUTPUT);   
114
pinMode(9, OUTPUT);       
115
digitalWrite(9,LOW);
116
​
117
}
118
​
119
// the loop routine runs over and over again forever:
120
void loop() {
121
  //tone(pin, note, duration)
122
    tone(13,LA3,Q); 
123
    delay(1+Q); //delay duration should always be 1 ms more than the note in order to separate them.
124
    tone(13,LA3,Q);
125
    delay(1+Q);
126
    tone(13,LA3,Q);
127
    delay(1+Q);
128
    tone(13,F3,E+S);
129
    delay(1+E+S);
130
    tone(13,C4,S);
131
    delay(1+S);
132
    
133
    tone(13,LA3,Q);
134
    delay(1+Q);
135
    tone(13,F3,E+S);
136
    delay(1+E+S);
137
    tone(13,C4,S);
138
    delay(1+S);
139
    tone(13,LA3,H);
140
    delay(1+H);
141
    
142
    tone(13,E4,Q); 
143
    delay(1+Q); 
144
    tone(13,E4,Q);
145
    delay(1+Q);
146
    tone(13,E4,Q);
147
    delay(1+Q);
148
    tone(13,F4,E+S);
149
    delay(1+E+S);
150
    tone(13,C4,S);
151
    delay(1+S);
152
    
153
    tone(13,Ab3,Q);
154
    delay(1+Q);
155
    tone(13,F3,E+S);
156
    delay(1+E+S);
157
    tone(13,C4,S);
158
    delay(1+S);
159
    tone(13,LA3,H);
160
    delay(1+H);
161
    
162
    tone(13,LA4,Q);
163
    delay(1+Q);
164
    tone(13,LA3,E+S);
165
    delay(1+E+S);
166
    tone(13,LA3,S);
167
    delay(1+S);
168
    tone(13,LA4,Q);
169
    delay(1+Q);
170
    tone(13,Ab4,E+S);
171
    delay(1+E+S);
172
    tone(13,G4,S);
173
    delay(1+S);
174
    
175
    tone(13,Gb4,S);
176
    delay(1+S);
177
    tone(13,E4,S);
178
    delay(1+S);
179
    tone(13,F4,E);
180
    delay(1+E);
181
    delay(1+E);//PAUSE
182
    tone(13,Bb3,E);
183
    delay(1+E);
184
    tone(13,Eb4,Q);
185
    delay(1+Q);
186
    tone(13,D4,E+S);
187
    delay(1+E+S);
188
    tone(13,Db4,S);
189
    delay(1+S);
190
    
191
    tone(13,C4,S);
192
    delay(1+S);
193
    tone(13,B3,S);
194
    delay(1+S);
195
    tone(13,C4,E);
196
    delay(1+E);
197
    delay(1+E);//PAUSE QUASI FINE RIGA
198
    tone(13,F3,E);
199
    delay(1+E);
200
    tone(13,Ab3,Q);
201
    delay(1+Q);
202
    tone(13,F3,E+S);
203
    delay(1+E+S);
204
    tone(13,LA3,S);
205
    delay(1+S);
206
    
207
    tone(13,C4,Q);
208
    delay(1+Q);
209
     tone(13,LA3,E+S);
210
    delay(1+E+S);
211
    tone(13,C4,S);
212
    delay(1+S);
213
    tone(13,E4,H);
214
    delay(1+H);
215
    
216
     tone(13,LA4,Q);
217
    delay(1+Q);
218
    tone(13,LA3,E+S);
219
    delay(1+E+S);
220
    tone(13,LA3,S);
221
    delay(1+S);
222
    tone(13,LA4,Q);
223
    delay(1+Q);
224
    tone(13,Ab4,E+S);
225
    delay(1+E+S);
226
    tone(13,G4,S);
227
    delay(1+S);
228
    
229
    tone(13,Gb4,S);
230
    delay(1+S);
231
    tone(13,E4,S);
232
    delay(1+S);
233
    tone(13,F4,E);
234
    delay(1+E);
235
    delay(1+E);//PAUSE
236
    tone(13,Bb3,E);
237
    delay(1+E);
238
    tone(13,Eb4,Q);
239
    delay(1+Q);
240
    tone(13,D4,E+S);
241
    delay(1+E+S);
242
    tone(13,Db4,S);
243
    delay(1+S);
244
    
245
    tone(13,C4,S);
246
    delay(1+S);
247
    tone(13,B3,S);
248
    delay(1+S);
249
    tone(13,C4,E);
250
    delay(1+E);
251
    delay(1+E);//PAUSE QUASI FINE RIGA
252
    tone(13,F3,E);
253
    delay(1+E);
254
    tone(13,Ab3,Q);
255
    delay(1+Q);
256
    tone(13,F3,E+S);
257
    delay(1+E+S);
258
    tone(13,C4,S);
259
    delay(1+S);
260
    
261
    tone(13,LA3,Q);
262
    delay(1+Q);
263
     tone(13,F3,E+S);
264
    delay(1+E+S);
265
    tone(13,C4,S);
266
    delay(1+S);
267
    tone(13,LA3,H);
268
    delay(1+H);
269
    
270
    delay(2*H);
271
    
272
}
273
​
RENAMED
Code/Otto_allmoves.ino
1
//----------------------------------------------------------------
2
//-- Otto All moves test
3
//-- This code will make Otto make all functions, you can reorganize moves, gestures or uncoment sings in the principal loop
4
//-- April 2019: Designed to work with the basic Otto but could be compatible with PLUS or Humanoid or other biped robots
5
/******************************************************************************************************
6
  Make sure to have installed all libraries: https://wikifactory.com/+OttoDIY/otto-diy
7
  Otto DIY invests time and resources providing open source code and hardware, 
8
  please support by purchasing kits from (https://www.ottodiy.com)
9
  
10
  BSD license, all text above must be included in any redistribution
11
 *******************************************************************/
12
//-----------------------------------------------------------------
13
#include <Servo.h> 
14
#include <Oscillator.h>
15
#include <Otto.h>
16
Otto Otto;  //This is Otto!
17
//----------------------------------------------------------------------
18
//-- Make sure the servos are in the right pin
19
/*             -------- 
20
              |  O  O  |
21
              |--------|
22
  RIGHT LEG 3 |        | LEFT LEG 2
23
               -------- 
24
               ||     ||
25
RIGHT FOOT 5 |---     ---| LEFT FOOT 4     
26
*/
27
  #define PIN_LEFTLEG 2 //servo[2]
28
  #define PIN_RIGHTLEG 3 //servo[3]
29
  #define PIN_LEFTFOOT 4 //servo[4]
30
  #define PIN_RIGHTFOOT 5 //servo[5]
31
///////////////////////////////////////////////////////////////////
32
//-- Setup ------------------------------------------------------//
33
///////////////////////////////////////////////////////////////////
34
void setup(){
35
  Otto.init(PIN_LEFTLEG,PIN_RIGHTLEG,PIN_LEFTFOOT,PIN_RIGHTFOOT,true); //Set the servo pins
36
  Otto.sing(S_connection); //Otto wake up!
37
  Otto.home();
38
  delay(50);
39
}
40
///////////////////////////////////////////////////////////////////
41
//-- Principal Loop ---------------------------------------------//
42
///////////////////////////////////////////////////////////////////
43
void loop() { 
44
          Otto.walk(2,1000,1); //2 steps, "TIME". IF HIGHER THE VALUE THEN SLOWER (from 600 to 1400), 1 FORWARD
45
          Otto.walk(2,1000,-1); //2 steps, T, -1 BACKWARD 
46
          Otto.turn(2,1000,1);//3 steps turning LEFT
47
          Otto.home();
48
          delay(100);  
49
          Otto.turn(2,1000,-1);//3 steps turning RIGHT 
50
          Otto.bend (1,500,1); //usually steps =1, T=2000
51
          Otto.bend (1,2000,-1);     
52
          Otto.shakeLeg (1,1500, 1);
53
          Otto.home();
54
          delay(100);
55
          Otto.shakeLeg (1,2000,-1);
56
          Otto.moonwalker(3, 1000, 25,1); //LEFT
57
          Otto.moonwalker(3, 1000, 25,-1); //RIGHT  
58
          Otto.crusaito(2, 1000, 20,1);
59
          Otto.crusaito(2, 1000, 20,-1);
60
          delay(100); 
61
          Otto.flapping(2, 1000, 20,1);
62
          Otto.flapping(2, 1000, 20,-1);
63
          delay(100);        
64
          Otto.swing(2, 1000, 20);
65
          Otto.tiptoeSwing(2, 1000, 20);
66
          Otto.jitter(2, 1000, 20); //(small T)
67
          Otto.updown(2, 1500, 20);  // 20 = H "HEIGHT of movement"T 
68
          Otto.ascendingTurn(2, 1000, 50);
69
          Otto.jump(1,2000);
70
          delay(50); 
71
       
72
          //Otto.sing(S_cuddly);
73
          //Otto.sing(S_OhOoh);
74
          //Otto.sing(S_OhOoh2);
75
          //Otto.sing(S_surprise);
76
          //Otto.sing(S_buttonPushed);       
77
          //Otto.sing(S_mode1);        
78
          //Otto.sing(S_mode2);         
79
          //Otto.sing(S_mode3);  
80
          //Otto.sing(S_sleeping);
81
          //Otto.sing(S_fart1);
82
          //Otto.sing(S_fart2);
83
          //Otto.sing(S_fart3);
84
          //Otto.sing(S_happy);
85
          //Otto.sing(S_happy_short);                   
86
          //Otto.sing(S_superHappy);   
87
          //Otto.sing(S_sad);               
88
          //Otto.sing(S_confused);
89
          //Otto.sing(S_disconnection);
90
          Otto.home();
91
          Otto.playGesture(OttoHappy);
92
          Otto.playGesture(OttoSuperHappy);
93
          Otto.playGesture(OttoSad);
94
          Otto.playGesture(OttoVictory); 
95
          Otto.playGesture(OttoAngry); 
96
          Otto.playGesture(OttoSleeping);
97
          Otto.playGesture(OttoFretful);
98
          Otto.playGesture(OttoLove);
99
          Otto.playGesture(OttoConfused);        
100
          Otto.playGesture(OttoFart);
101
          Otto.playGesture(OttoWave);
102
          Otto.playGesture(OttoMagic);
103
          Otto.playGesture(OttoFail);
104
          Otto.home();  
105
}
106
​
RENAMED
Code/Otto_avoid.ino
1
//----------------------------------------------------------------
2
//-- Otto Avoid obstacles 
3
//-- With this code Otto will walk until detects an obstacle with his ultrasound sensor you can open serial to read distance and test
4
//-- April 2019: Designed to work with the basic Otto but could be compatible with PLUS or Humanoid or other biped robots
5
/******************************************************************************************************
6
  Make sure to have installed all libraries: https://wikifactory.com/+OttoDIY/otto-diy
7
  Otto DIY invests time and resources providing open source code and hardware, 
8
  please support by purchasing kits from (https://www.ottodiy.com)
9
  
10
  BSD license, all text above must be included in any redistribution
11
 *******************************************************************/
12
//-----------------------------------------------------------------
13
#include <Servo.h> 
14
#include <Oscillator.h>
15
#include <US.h>
16
#include <Otto.h>
17
Otto Otto;  //This is Otto!
18
//---------------------------------------------------------
19
//-- Make sure the servos are in the right pin, double check your Ultrasound zensor some have TRIG and ECHO swapped!
20
/*             -------- 
21
              |  O  O  |
22
              |--------|
23
  RIGHT LEG 3 |        | LEFT LEG 2
24
               -------- 
25
               ||     ||
26
RIGHT FOOT 5 |---     ---| LEFT FOOT 4  
27
*/
28
#define PIN_LEFT_LEG   2   
29
#define PIN_RIGHT_LEG  3  
30
#define PIN_LEFT_FOOT  4  
31
#define PIN_RIGHT_FOOT 5 
32
​
33
  #define ECHOPIN 9        // Pin to receive echo pulse
34
  #define TRIGPIN 8        // Pin to send trigger pulse
35
  #define Buzzer  13
36
///////////////////////////////////////////////////////////////////
37
//-- Global Variables -------------------------------------------//
38
///////////////////////////////////////////////////////////////////
39
//-- Movement parameters
40
int T=1000;              //Initial duration of movement
41
int moveId=0;            //Number of movement
42
int moveSize=15;         //Asociated with the height of some movements
43
//---------------------------------------------------------
44
bool obstacleDetected = false;
45
///////////////////////////////////////////////////////////////////
46
//-- Setup ------------------------------------------------------//
47
///////////////////////////////////////////////////////////////////
48
void setup(){
49
  Serial.begin(19200);
50
  //Set the servo pins
51
  Otto.init(PIN_LEFT_LEG,PIN_RIGHT_LEG,PIN_LEFT_FOOT,PIN_RIGHT_FOOT,true);
52
  Otto.sing(S_connection); //Otto wake up!
53
  Otto.home();
54
  delay(50);
55
  Otto.sing(S_happy); // a happy Otto :)
56
​
57
  pinMode(ECHOPIN, INPUT);
58
  pinMode(TRIGPIN, OUTPUT);
59
}
60
///////////////////////////////////////////////////////////////////
61
//-- Principal Loop ---------------------------------------------//
62
///////////////////////////////////////////////////////////////////
63
void loop() {
64
  if(obstacleDetected){ 
65
               Otto.sing(S_surprise); 
66
               Otto.playGesture(OttoSad); 
67
               Otto.walk(3,1300,-1); 
68
               Otto.turn(3,1000,-1);                
69
             delay(50); 
70
             obstacleDetector(); 
71
             }        
72
         else{ 
73
            Otto.walk(1,1000,1); 
74
            obstacleDetector(); 
75
        }           
76
  }  
77
//////////////////////////////////////////////////////////////////////////////////
78
//-- Function to read distance sensor & to actualize obstacleDetected variable //
79
/////////////////////////////////////////////////////////////////////////////////
80
void obstacleDetector(){
81
// Start Ranging
82
  digitalWrite(TRIGPIN, LOW);
83
  delayMicroseconds(2);
84
  digitalWrite(TRIGPIN, HIGH);
85
  delayMicroseconds(10);
86
  digitalWrite(TRIGPIN, LOW);
87
// Compute distance
88
  float distance = pulseIn(ECHOPIN, HIGH);
89
  distance= distance/58;
90
  Serial.print(distance);
91
  Serial.println("cm");
92
 if(distance<15){
93
          obstacleDetected = true;
94
          Serial.println ("Obstacle Detected! Avoid collision");
95
        }else{
96
          obstacleDetected = false;
97
          Serial.println ("No Obstacle detected! - Keep on walking");
98
        }
99
  
100
}
101
​
RENAMED
Code/Otto_avoid_TRIMS.ino
1
//----------------------------------------------------------------
2
//-- Otto Avoid obstacles with TRIMS servo calibration values to modify
3
//-- With this code Otto will walk until detects an obstacle with his ultrasound sensor you can open serial to read distance and test
4
//-- April 2019: Designed to work with the basic Otto but could be compatible with PLUS or Humanoid or other biped robots
5
/******************************************************************************************************
6
  Make sure to have installed all libraries: https://wikifactory.com/+OttoDIY/otto-diy
7
  Otto DIY invests time and resources providing open source code and hardware, 
8
  please support by purchasing kits from (https://www.ottodiy.com)
9
  
10
  BSD license, all text above must be included in any redistribution
11
 *******************************************************************/
12
//-----------------------------------------------------------------
13
#include <Servo.h> 
14
#include <Oscillator.h>
15
#include <US.h>
16
#include <Otto.h>
17
Otto Otto;  //This is Otto!
18
//----------------------------------------------------------------------
19
//-- Make sure the servos are in the right pin, double check your Ultrasound zensor some have TRIG and ECHO swapped!
20
/*             -------- 
21
              |  O  O  |
22
              |--------|
23
  RIGHT LEG 3 |        | LEFT LEG 2
24
               -------- 
25
               ||     ||
26
RIGHT FOOT 5 |---     ---| LEFT FOOT 4  
27
*/
28
​
29
#define PIN_LEFT_LEG   2   
30
#define PIN_RIGHT_LEG  3  
31
#define PIN_LEFT_FOOT  4  
32
#define PIN_RIGHT_FOOT 5 
33
 
34
#define TRIM_LEFT_LEG   0 
35
#define TRIM_RIGHT_LEG  0
36
#define TRIM_LEFT_FOOT  0 
37
#define TRIM_RIGHT_FOOT 0
38
///////////////////////////////////////////////////////////////////
39
//-- Setup ------------------------------------------------------//
40
///////////////////////////////////////////////////////////////////
41
void setup()
42
{
43
  Serial.begin(9600);
44
  Serial.println("Hello Otto Builder");
45
  Otto.init(PIN_LEFT_LEG,PIN_RIGHT_LEG,PIN_LEFT_FOOT,PIN_RIGHT_FOOT,true); //Set the servo pins
46
  Otto.setTrims(TRIM_LEFT_LEG,TRIM_RIGHT_LEG, TRIM_LEFT_FOOT, TRIM_RIGHT_FOOT);
47
  Otto.sing(S_connection); //Otto wake up!
48
  Otto.home();
49
}
50
///////////////////////////////////////////////////////////////////
51
//-- Principal Loop ---------------------------------------------//
52
///////////////////////////////////////////////////////////////////
53
void loop() 
54
{
55
  bool obstacleDetected = false;
56
  
57
  obstacleDetected = obstacleDetector(); 
58
  
59
  if(obstacleDetected)
60
  { 
61
        Otto.sing(S_surprise); 
62
        Otto.walk(7,1000,BACKWARD); 
63
        delay(1000);
64
        Otto.sing(S_happy);
65
        Otto.turn(10,1000,RIGHT);                
66
        delay(2000); 
67
          
68
   }        
69
   else
70
   { 
71
          Otto.walk(1,1000,FORWARD);  
72
    }          
73
 }  
74
​
75
///////////////////////////////////////////////////////////////////
76
//-- Function to read distance sensor & to actualize obstacleDetected variable
77
bool obstacleDetector()
78
{
79
   int distance = Otto.getDistance();
80
   
81
   Serial.println(distance);
82
   
83
   if(distance<15)
84
   {
85
      return true;
86
   }
87
   else
88
   {
89
      return false;
90
   }
91
}
92
​
RENAMED
Code/Otto_avoid_mhs.ino
1
//----------------------------------------------------------------
2
//-- CC BY SA (http://ottodiy.com)
3
//-- 16 January 2017 - Modified by MHs, Ultra Sound fixed
4
//-- double check your US (Ultra sound) module some have TRIG and ECHO swapped!
5
//-----------------------------------------------------------------
6
//-- Otto will avoid obstacles with this code!
7
//-----------------------------------------------------------------
8
#include <Servo.h> 
9
#include <Oscillator.h>
10
#include <US.h>
11
#include <Otto.h>
12
Otto Otto;  //This is Otto!
13
//---------------------------------------------------------
14
//-- First step: Make sure the pins for servos are in the right position
15
/*
16
         --------------- 
17
        |     O   O     |
18
        |---------------|
19
YR 3==> |               | <== YL 2 yaw left
20
         --------------- 
21
            ||     ||
22
RR 5==>   -----   ------  <== RL 4 roll left
23
         |-----   ------|
24
*/
25
  #define PIN_YL 2 //servo[2]
26
  #define PIN_YR 3 //servo[3]
27
  #define PIN_RL 4 //servo[4]
28
  #define PIN_RR 5 //servo[5]
29
​
30
  #define ECHOPIN 9        // Pin to receive echo pulse
31
  #define TRIGPIN 8        // Pin to send trigger pulse
32
​
33
///////////////////////////////////////////////////////////////////
34
//-- Global Variables -------------------------------------------//
35
///////////////////////////////////////////////////////////////////
36
//-- Movement parameters
37
int T=1000;              //Initial duration of movement
38
int moveId=0;            //Number of movement
39
int moveSize=15;         //Asociated with the height of some movements
40
//---------------------------------------------------------
41
bool obstacleDetected = false;
42
///////////////////////////////////////////////////////////////////
43
//-- Setup ------------------------------------------------------//
44
///////////////////////////////////////////////////////////////////
45
void setup(){
46
  Serial.begin(19200);
47
  //Set the servo pins
48
  Otto.init(PIN_YL,PIN_YR,PIN_RL,PIN_RR,true, -1, 13, 8, 9);
49
  Otto.sing(S_connection); //Otto wake up!
50
  Otto.home();
51
  delay(50);
52
  Otto.sing(S_happy); // a happy Otto :)
53
​
54
  pinMode(ECHOPIN, INPUT);
55
  pinMode(TRIGPIN, OUTPUT);
56
}
57
///////////////////////////////////////////////////////////////////
58
//-- Principal Loop ---------------------------------------------//
59
///////////////////////////////////////////////////////////////////
60
void loop() {
61
  if(obstacleDetected){ 
62
               Otto.sing(S_surprise); 
63
               Otto.playGesture(OttoFretful); 
64
               Otto.sing(S_fart3); 
65
               Otto.walk(2,1300,-1); 
66
               Otto.turn(2,1000,-1);                
67
             delay(50); 
68
             obstacleDetector(); 
69
             }        
70
         else{ 
71
            Otto.walk(1,1000,1); 
72
            obstacleDetector(); 
73
        }           
74
  }  
75
//////////////////////////////////////////////////////////////////////////////////
76
//-- Function to read distance sensor & to actualize obstacleDetected variable //
77
/////////////////////////////////////////////////////////////////////////////////
78
void obstacleDetector(){
79
// Start Ranging
80
  digitalWrite(TRIGPIN, LOW);
81
  delayMicroseconds(2);
82
  digitalWrite(TRIGPIN, HIGH);
83
  delayMicroseconds(10);
84
  digitalWrite(TRIGPIN, LOW);
85
// Compute distance
86
  float distance = pulseIn(ECHOPIN, HIGH);
87
  distance= distance/58;
88
  Serial.print(distance);
89
  Serial.println("cm");
90
 if(distance<15){
91
          obstacleDetected = true;
92
          Serial.println ("Obstacle Detected! Avoid collision");
93
        }else{
94
          obstacleDetected = false;
95
          Serial.println ("No Obstacle detected! - Keep on walking");
96
        }
97
  
98
}
99
​
RENAMED
Code/Otto_easycalibration.ino
1
//----------------------------------------------------------------
2
//-- Otto Easy calibration
3
//-- With this code you can calibrate the servo motors butit will require to adjust the TRIM values
4
//-- April 2019: Designed to work with the basic Otto but could be compatible with PLUS or Humanoid or other biped robots
5
/******************************************************************************************************
6
  Make sure to have installed all libraries: https://wikifactory.com/+OttoDIY/otto-diy
7
  Otto DIY invests time and resources providing open source code and hardware, 
8
  please support by purchasing kits from (https://www.ottodiy.com)
9
  
10
  BSD license, all text above must be included in any redistribution
11
 *******************************************************************/                                                    
12
//-- VERY IMPORTANT only calibrate ONE TIME per board!to avoid damage EEPROM memory
13
//-----------------------------------------------------------------
14
#include <Otto.h>
15
#include <Servo.h>
16
#include <Oscillator.h>
17
#include <EEPROM.h>
18
Otto Otto;
19
​
20
void setup()
21
{
22
  Otto.init(2, 3, 4, 5, false);
23
  Otto.setTrims(-7,-4,-4,7); //change Trim "offset values" gradually until Otto is completely straight (90º)
24
 // Otto.saveTrimsOnEEPROM(); //use only after completely straight(90º), delete this line after for further programming
25
}
26
int posiciones[] = {90, 90, 90, 90};
27
​
28
void loop()  //test comparing before & after function
29
{
30
  Otto.home();
31
 // delay(4000);
32
 // Otto.updown(6, 500, BIG);   
33
 // delay(2000);
34
 //   
35
 // Otto.walk(4,1800);
36
 //delay(2000);
37
}
38
​
RENAMED
Code/Otto_happybirthday.ino
1
//----------------------------------------------------------------
2
//-- Otto Happy Birthday
3
//-- With this code Otto will walk 5 steps and then sing the happy birthday
4
//-- April 2019: Designed to work with the basic Otto but could be compatible with PLUS or Humanoid or other biped robots
5
/******************************************************************************************************
6
  Make sure to have installed all libraries: https://wikifactory.com/+OttoDIY/otto-diy
7
  Otto DIY invests time and resources providing open source code and hardware, 
8
  please support by purchasing kits from (https://www.ottodiy.com)
9
  
10
  BSD license, all text above must be included in any redistribution
11
 *******************************************************************/
12
//-----------------------------------------------------------------
13
#include <Servo.h> 
14
#include <Oscillator.h>
15
#include <US.h>
16
#include <Otto.h>
17
Otto Otto;  //This is Otto!
18
#define PIN_LEFT_LEG   2   
19
#define PIN_RIGHT_LEG  3  
20
#define PIN_LEFT_FOOT  4  
21
#define PIN_RIGHT_FOOT 5 
22
int speakerPin = 13;
23
int length = 28; // the number of notes
24
char notes[] = "GGAGcB GGAGdc GGxecBA yyecdc";
25
int beats[] = { 2, 2, 8, 8, 8, 16, 1, 2, 2, 8, 8,8, 16, 1, 2,2,8,8,8,8,16, 1,2,2,8,8,8,16 };
26
int tempo = 150;
27
​
28
void playTone(int tone, int duration) {
29
​
30
for (long i = 0; i < duration * 1000L; i += tone * 2) {
31
   digitalWrite(speakerPin, HIGH);
32
   delayMicroseconds(tone);
33
   digitalWrite(speakerPin, LOW);
34
   delayMicroseconds(tone);
35
}
36
}
37
void playNote(char note, int duration) {
38
​
39
char names[] = {'C', 'D', 'E', 'F', 'G', 'A', 'B',           
40
​
41
                 'c', 'd', 'e', 'f', 'g', 'a', 'b',
42
​
43
                 'x', 'y' };
44
​
45
int tones[] = { 1915, 1700, 1519, 1432, 1275, 1136, 1014,
46
​
47
                 956,  834,  765,  593,  468,  346,  224,
48
​
49
                 655 , 715 };
50
​
51
int SPEE = 5; // play the tone corresponding to the note name
52
​
53
for (int i = 0; i < 17; i++) {
54
   if (names[i] == note) {
55
    int newduration = duration/SPEE;
56
     playTone(tones[i], newduration);
57
   }
58
}
59
}
60
​
61
void setup() {
62
  Otto.init(PIN_LEFT_LEG,PIN_RIGHT_LEG,PIN_LEFT_FOOT,PIN_RIGHT_FOOT,true);
63
pinMode(speakerPin, OUTPUT);
64
}
65
​
66
void loop() {
67
  Otto.walk(5,1300,1); 
68
  Otto.playGesture(OttoSuperHappy);
69
for (int i = 0; i < length; i++) {
70
   if (notes[i] == ' ') {
71
     delay(beats[i] * tempo); // rest
72
   } else {
73
     playNote(notes[i], beats[i] * tempo);
74
   }
75
   // pause between notes
76
   delay(tempo);   
77
}
78
}
79
​
RENAMED
Code/Otto_jingle.ino
1
// TONES  ========================================== // Start by defining the relationship between
2
 //       note, period, &  frequency.
3
 #define  C     2100
4
 #define  D     1870 
5
 #define  E     1670
6
 #define  f     1580    // Does not seem to like capital F
7
 #define  G     1400 
8
 // Define a special note, 'R', to represent a rest
9
 #define  R     0
10
 // SETUP ============================================
11
 // Set up speaker on a PWM pin (digital 9, 10 or 11)
12
 int speakerOut = 13;
13
 // Do we want debugging on serial out? 1 for yes, 0 for no
14
 int DEBUG = 1;
15
 void setup() {
16
   pinMode(speakerOut, OUTPUT);
17
   if (DEBUG) {
18
     Serial.begin(9600); // Set serial out if we want debugging
19
   }
20
 }
21
 // MELODY and TIMING  =======================================
22
 //  melody[] is an array of notes, accompanied by beats[],
23
 //  which sets each note's relative length (higher #, longer note)
24
 int melody[] = {E, E, E,R,
25
 E, E, E,R,
26
 E, G, C, D, E, R,
27
 f, f, f,f, f, E, E,E, E, D ,D,E, D, R, G ,R,
28
 E, E, E,R,
29
 E, E, E,R,
30
 E, G, C, D, E, R,
31
 f, f, f,f, f, E, E, E,  G,G, f, D, C,R };
32
 int MAX_COUNT = sizeof(melody) / 2; // Melody length, for looping.
33
 // Set overall tempo
34
 long tempo = 5000;
35
 // Set length of pause between notes
36
 int pause = 150;
37
 // Loop variable to increase Rest length
38
 int rest_count = 100; //<-BLETCHEROUS HACK; See NOTES
39
 // Initialize core variables
40
 int tone_ = 0;
41
 int beat = 0;
42
 long duration  = 0;
43
 // PLAY TONE  ==============================================
44
 // Pulse the speaker to play a tone for a particular duration
45
 void playTone() {
46
   long elapsed_time = 0;
47
   if (tone_ > 0) { // if this isn't a Rest beat, while the tone has
48
     //  played less long than 'duration', pulse speaker HIGH and LOW
49
     while (elapsed_time < duration) {
50
       digitalWrite(speakerOut,HIGH);
51
       delayMicroseconds(tone_ / 2);
52
       // DOWN
53
       digitalWrite(speakerOut, LOW);
54
       delayMicroseconds(tone_ / 2);
55
       // Keep track of how long we pulsed
56
       elapsed_time += (tone_);
57
     }
58
   }
59
   else { // Rest beat; loop times delay
60
     for (int j = 0; j < rest_count; j++) { // See NOTE on rest_count
61
       delayMicroseconds(duration); 
62
     } 
63
   }                                
64
 }
65
 // LET THE WILD RUMPUS BEGIN =============================
66
 void loop() {
67
  for (int i=0; i<MAX_COUNT; i++) {
68
    tone_ = melody[i];
69
    beat = 50;
70
​
71
    duration = beat * tempo; // Set up timing
72
​
73
    playTone();
74
    // A pause between notes...
75
    delayMicroseconds(pause);
76
  }
77
 }
78
​
RENAMED
Code/Otto_retrieve.ino
1
//----------------------------------------------------------------
2
//-- Otto Push
3
//-- With this Otto will retrieve everytime you put something in front of the Ultra sound but, Can you make Otto follow you?
4
//-- April 2019: Designed to work with the basic Otto but could be compatible with PLUS or Humanoid or other biped robots
5
/******************************************************************************************************
6
  Make sure to have installed all libraries: https://wikifactory.com/+OttoDIY/otto-diy
7
  Otto DIY invests time and resources providing open source code and hardware, 
8
  please support by purchasing kits from (https://www.ottodiy.com)
9
  
10
  BSD license, all text above must be included in any redistribution
11
 *******************************************************************/
12
//-----------------------------------------------------------------
13
#include <Servo.h> 
14
#include <Oscillator.h>
15
#include <US.h>
16
#include <Otto.h>
17
Otto Otto;  //This is Otto!
18
//---------------------------------------------------------
19
//-- Make sure the servos are in the right pin
20
/*             -------- 
21
              |  O  O  |
22
              |--------|
23
  RIGHT LEG 3 |        | LEFT LEG 2
24
               -------- 
25
               ||     ||
26
RIGHT FOOT 5 |---     ---| LEFT FOOT 4     
27
*/
28
  #define PIN_LEFTLEG 2 //servo[2]
29
  #define PIN_RIGHTLEG 3 //servo[3]
30
  #define PIN_LEFTFOOT 4 //servo[4]
31
  #define PIN_RIGHTFOOT 5 //servo[5]
32
///////////////////////////////////////////////////////////////////
33
//-- Global Variables -------------------------------------------//
34
///////////////////////////////////////////////////////////////////
35
//-- Movement parameters
36
int T=1000;              //Initial duration of movement
37
int moveId=0;            //Number of movement
38
int moveSize=15;         //Asociated with the height of some movements
39
//---------------------------------------------------------
40
bool obstacleDetected = false;
41
///////////////////////////////////////////////////////////////////
42
//-- Setup ------------------------------------------------------//
43
///////////////////////////////////////////////////////////////////
44
void setup(){
45
  Otto.init(PIN_LEFTLEG,PIN_RIGHTLEG,PIN_LEFTFOOT,PIN_RIGHTFOOT,true); //Set the servo pins
46
  Otto.sing(S_connection); //Otto wake up!
47
  Otto.home();
48
  delay(50);
49
  Otto.sing(S_happy); // a happy Otto :)
50
}
51
///////////////////////////////////////////////////////////////////
52
//-- Principal Loop ---------------------------------------------//
53
///////////////////////////////////////////////////////////////////
54
void loop() {
55
  if(obstacleDetected){ 
56
               Otto.walk(1,1000,1);  //Otto.walk(1,1000,1) to make Otto follow you!
57
             obstacleDetector(); 
58
             }        
59
         else{ 
60
            Otto.home();
61
            obstacleDetector(); 
62
        }           
63
  }  
64
///////////////////////////////////////////////////////////////////
65
//-- Function to read distance sensor & to actualize obstacleDetected variable
66
void obstacleDetector(){
67
   int distance = Otto.getDistance();
68
        if(distance<15){
69
          obstacleDetected = true;
70
        }else{
71
          obstacleDetected = false;
72
        }
73
}
74
​
RENAMED
Code/Otto_run.ino
1
//----------------------------------------------------------------
2
//-- Otto Run!
3
//-- This code will make Otto run fast
4
//-- April 2019: Designed to work with the basic Otto but could be compatible with PLUS or Humanoid or other biped robots
5
/******************************************************************************************************
6
  Make sure to have installed all libraries: https://wikifactory.com/+OttoDIY/otto-diy
7
  Otto DIY invests time and resources providing open source code and hardware, 
8
  please support by purchasing kits from (https://www.ottodiy.com)
9
  
10
  BSD license, all text above must be included in any redistribution
11
 *******************************************************************/
12
//-----------------------------------------------------------------
13
#include <Servo.h> 
14
#include <Oscillator.h>
15
#include <US.h>
16
#include <Otto.h>
17
Otto Otto;  //This is Otto!
18
//---------------------------------------------------------
19
//-- Make sure the servos are in the right pin
20
/*             -------- 
21
              |  O  O  |
22
              |--------|
23
  RIGHT LEG 3 |        | LEFT LEG 2
24
               -------- 
25
               ||     ||
26
RIGHT FOOT 5 |---     ---| LEFT FOOT 4     
27
*/
28
  #define PIN_LEFTLEG 2 //servo[2]
29
  #define PIN_RIGHTLEG 3 //servo[3]
30
  #define PIN_LEFTFOOT 4 //servo[4]
31
  #define PIN_RIGHTFOOT 5 //servo[5]
32
///////////////////////////////////////////////////////////////////
33
//-- Global Variables -------------------------------------------//
34
///////////////////////////////////////////////////////////////////
35
//-- Movement parameters
36
int T=1000;              //Initial duration of movement
37
int moveId=0;            //Number of movement
38
int moveSize=15;         //Asociated with the height of some movements
39
//---------------------------------------------------------
40
bool obstacleDetected = false;
41
///////////////////////////////////////////////////////////////////
42
//-- Setup ------------------------------------------------------//
43
///////////////////////////////////////////////////////////////////
44
void setup(){
45
  Otto.init(PIN_LEFTLEG,PIN_RIGHTLEG,PIN_LEFTFOOT,PIN_RIGHTFOOT,true); //Set the servo pins
46
  Otto.sing(S_connection); //Otto wake up!
47
  Otto.home();
48
  delay(50);
49
  Otto.sing(S_happy); // a happy Otto :)
50
}
51
///////////////////////////////////////////////////////////////////
52
//-- Principal Loop ---------------------------------------------//
53
///////////////////////////////////////////////////////////////////
54
void loop() {
55
               Otto.walk(2,500,1); //change T for lower value to run faster!                    
56
             delay(50); }
57
         
58
///////////////////////////////////////////////////////////////////
59
//-- Function to read distance sensor & to actualize obstacleDetected variable
60
void obstacleDetector(){
61
   int distance = Otto.getDistance();
62
        if(distance<15){
63
          obstacleDetected = true;
64
        }else{
65
          obstacleDetected = false;
66
        }
67
}
68
​
RENAMED
Code/Otto_singleladies.ino
1
//----------------------------------------------------------------
2
//-- Otto Dance single ladies
3
//-- This code will make Otto dance play the by Beyonce song at the same time and see it in action
4
//-- April 2019: Designed to work with the basic Otto but could be compatible with PLUS or Humanoid or other biped robots
5
/******************************************************************************************************
6
  Make sure to have installed all libraries: https://wikifactory.com/+OttoDIY/otto-diy
7
  Otto DIY invests time and resources providing open source code and hardware, 
8
  please support by purchasing kits from (https://www.ottodiy.com)
9
  
10
  BSD license, all text above must be included in any redistribution
11
 *******************************************************************/
12
//-----------------------------------------------------------------
13
#include <Servo.h>
14
#include <Oscillator.h>
15
#include <EEPROM.h>
16
​
17
#define N_SERVOS 4
18
#define EEPROM_TRIM false //Activate for calibration
19
​
20
#define TRIM_RR 18
21
#define TRIM_RL 18
22
#define TRIM_YR 26
23
#define TRIM_YL 18
24
​
25
#define PIN_RL 2
26
#define PIN_RR 3
27
#define PIN_YR 4
28
#define PIN_YL 5
29
​
30
#define INTERVALTIME 10.0 
31
​
32
Oscillator servo[N_SERVOS];
33
​
34
void drunk (int tempo);
35
void kickLeft(int tempo);
36
void kickRight(int tempo);
37
void pasitos(int steps, int tempo);
38
void run(int steps, int T=500);
39
void walk(int steps, int T=1000);
40
void backyard(int steps, int T=3000);
41
void moonWalkLeft(int steps, int T=1000);
42
void moonWalkRight(int steps, int T=1000);
43
void crusaito(int steps, int T=1000);
44
void swing(int steps, int T=1000);
45
void upDown(int steps, int tempo);
46
void flapping(int steps, int T=1000);
47
​
48
void setup()
49
{
50
  Serial.begin(19200);
51
  
52
  servo[0].attach(PIN_RR);
53
  servo[1].attach(PIN_RL);
54
  servo[2].attach(PIN_YR);
55
  servo[3].attach(PIN_YL);
56
  
57
  int trim;
58
  
59
  if(EEPROM_TRIM){
60
    for(int x=0;x<4;x++){
61
      trim=EEPROM.read(x);
62
      if(trim>128)trim=trim-256;
63
      Serial.print("TRIM ");
64
      Serial.print(x);
65
      Serial.print(" en ");
66
      Serial.println(trim);
67
      servo[x].SetTrim(trim);
68
    }
69
  }
70
  else{
71
    servo[0].SetTrim(TRIM_RR);
72
    servo[1].SetTrim(TRIM_RL);
73
    servo[2].SetTrim(TRIM_YR);
74
    servo[3].SetTrim(TRIM_YL);
75
  }
76
  
77
  for(int i=0;i<4;i++) servo[i].SetPosition(90);
78
​
79
}
80
​
81
// TEMPO: 97 BPM
82
int t=620;
83
double pause=0;
84
​
85
void loop() {
86
  
87
  pasitos(8,t*2);
88
  crusaito(1,t);
89
  patada(t);
90
  delay(t);
91
  twist(2,t);
92
  twist(3,t/2);
93
  upDown(1,t*2);
94
  patada(t*2);
95
  drunk(t*2);
96
  flapping(1,t*2);
97
  walk(2,t);
98
  walk(1,t*2);
99
  backyard(2,t);
100
  patada(t*2);
101
  flapping(1,t*2);
102
  patada(t*2);
103
  twist(8,t/2);
104
  moonWalkLeft(2,t);
105
  crusaito(1,t*2);
106
  
107
  for(int i=0; i<2 ;i++){
108
    lateral_fuerte(0,t);
109
    lateral_fuerte(1,t);
110
    upDown(1,t*2);
111
  }
112
  
113
  saludo(1,t*2);
114
  saludo(1,t);
115
  delay(t);
116
  swing(3,t);
117
  for(int i=0;i<4;i++) servo[i].SetPosition(90);
118
  delay(t);
119
  
120
  lateral_fuerte(0,t);
121
  lateral_fuerte(1,t);
122
  lateral_fuerte(0,t/2);
123
  lateral_fuerte(1,t/2);
124
  lateral_fuerte(0,t/2);
125
  delay(t/2);
126
  lateral_fuerte(0,t);
127
  lateral_fuerte(1,t);
128
  lateral_fuerte(0,t/2);
129
  lateral_fuerte(1,t/2);
130
  delay(t);
131
  
132
  pasitos(1,t*2);
133
  pasitos(1,t);
134
  delay(t/2);
135
  pasitos(1,t*2);
136
  pasitos(1,t);
137
  delay(t/2);
138
     
139
  crusaito(2,t);
140
  crusaito(1,t*2);
141
  crusaito(2,t);
142
  crusaito(1,t*2);
143
  crusaito(2,t);
144
  crusaito(1,t*2);
145
  
146
  upDown(2,t);
147
  crusaito(1,t*2);
148
  for(int i=0;i<4;i++) servo[i].SetPosition(90);
149
  delay(t/2);
150
  pasitos(2,t*2);
151
  pasitos(2,t);
152
  flapping(1,t*2);
153
  upDown(2,t);
154
  upDown(1,t*2);
155
  
156
  for (int i=0; i<4; i++){
157
    pasitos(1,t);
158
    delay(t);
159
  }
160
  reverencia1(1,t*4);
161
  reverencia2(1,t*4);
162
  upDown(1,t);
163
  run(2,t/2);
164
  patada(t*2);
165
​
166
  lateral_fuerte(0,t);
167
  lateral_fuerte(1,t);
168
  upDown(2,t);
169
  lateral_fuerte(0,t);
170
  lateral_fuerte(1,t);
171
  upDown(2,t);
172
  pasitos(4,t);
173
  lateral_fuerte(0,t);
174
  lateral_fuerte(1,t);
175
  upDown(2,t);
176
  
177
  patada(t*2);
178
  pasitos(2,t);
179
  patada(t*2);
180
  pasitos(2,t);
181
  swing(2,t*2);
182
  pasitos(4,t);
183
  
184
  for (int i=0; i<4; i++){
185
    lateral_fuerte(0,t);
186
    lateral_fuerte(1,t);
187
    lateral_fuerte(0,t/2);
188
    lateral_fuerte(1,t/2);
189
    lateral_fuerte(0,t/2);
190
  delay(t/2);
191
  }
192
  
193
  pasitos(6,t);
194
  delay(t);
195
  pasitos(1,t);
196
  delay(t/2);
197
  pasitos(3,t);
198
  delay(t/2);
199
  swing(4,t);
200
  
201
  twist(2,t/2);
202
  delay(t/2);
203
  twist(2,t/2);
204
  delay(t/2);
205
  
206
  drunk(t*2);
207
  drunk(t/2);
208
  drunk(t*2);
209
  delay(t/2);
210
  walk(1,t);
211
  backyard(1,t);
212
  
213
  servo[0].SetPosition(110);
214
  servo[1].SetPosition(130);
215
  delay(t);
216
  
217
  crusaito(3,t);
218
  crusaito(1,2*t);
219
  upDown(1,t*2);
220
  upDown(2,t/2);
221
  
222
  kickLeft(t/2);
223
  kickRight(t/2);
224
  moonWalkLeft(1,t*2);
225
  moonWalkLeft(2,t);
226
  moonWalkRight(1,t*2);
227
  moonWalkRight(2,t);
228
  
229
  walk(4,t);
230
  backyard(4,t);
231
  
232
  lateral_fuerte(0,t);
233
  lateral_fuerte(0,t);
234
  lateral_fuerte(1,t);
235
  lateral_fuerte(1,t);
236
  walk(2,t);
237
  backyard(2,t);
238
  
239
  pasitos(6,t*2);
240
  swing(1,t);
241
  upDown(1,t);
242
  delay(t);
243
  upDown(6,t);
244
  delay(t);
245
  
246
  for (int i=0;i<4;i++){
247
    lateral_fuerte(0,t);
248
    lateral_fuerte(1,t);
249
  }
250
  
251
  delay(t);
252
  for (int i=0;i<7;i++){
253
    pasitos(2,t);
254
    swing(2,t);
255
  }
256
  
257
  pasitos(1,t);
258
  crusaito(1,t*2);
259
  upDown(1,t);
260
  
261
  delay(2000);
262
  
263
​
264
}
265
​
266
////////////////////////////////////////////////////////////////////////////////////////
267
//////////////////////////////////FUNCIONES DE CONTROL//////////////////////////////////
268
////////////////////////////////////////////////////////////////////////////////////////
269
​
270
void oscillate(int A[N_SERVOS], int O[N_SERVOS], int T, double phase_diff[N_SERVOS]){
271
  for (int i=0; i<4; i++) {
272
    servo[i].SetO(O[i]);
273
    servo[i].SetA(A[i]);
274
    servo[i].SetT(T);
275
    servo[i].SetPh(phase_diff[i]);
276
  }
277
  double ref=millis();
278
   for (double x=ref; x<T+ref; x=millis()){
279
     for (int i=0; i<4; i++){
280
        servo[i].refresh();
281
     }
282
  }
283
}
284
​
285
unsigned long final_time;
286
unsigned long interval_time;
287
int oneTime;
288
int iteration;
289
float increment[N_SERVOS]; 
290
int oldPosition[]={90,90,90,90};
291
​
292
void moveNServos(int time, int  newPosition[]){
293
  for(int i=0;i<N_SERVOS;i++)   increment[i] = ((newPosition[i])-oldPosition[i])/(time/INTERVALTIME);
294
  
295
  final_time =  millis() + time; 
296
  
297
  iteration = 1; 
298
  while(millis() < final_time){ //Javi del futuro cambia esto  
299
      interval_time = millis()+INTERVALTIME;  
300
      
301
      oneTime=0;      
302
      while(millis()<interval_time){      
303
          if(oneTime<1){ 
304
              for(int i=0;i<N_SERVOS;i++){
305
                  servo[i].SetPosition(oldPosition[i] + (iteration * increment[i]));
306
              }         
307
              iteration++;
308
              oneTime++;
309
          }
310
      }     
311
  }   
312
​
313
  for(int i=0;i<N_SERVOS;i++){  
314
    oldPosition[i] = newPosition[i];
315
  }   
316
}
317
​
318
​
319
//////////////////////////////////////////////////////////////////////////////
320
////////////////////////////////PASOS DE BAILE////////////////////////////////
321
//////////////////////////////////////////////////////////////////////////////
322
​
323
void pasitos(int steps, int tempo){
324
  int move1[4] = {90,120,60,60};
325
  int move2[4] = {90,90,90,90};
326
  int move3[4] = {60,90,120,120};
327
  int move4[4] = {90,90,90,90};
328
  
329
  for(int i=0; i<steps; i++){
330
    pause=millis();
331
    moveNServos(tempo*0.25,move1);
332
    moveNServos(tempo*0.25,move2);
333
    moveNServos(tempo*0.25,move3);
334
    moveNServos(tempo*0.25,move4);
335
    while(millis()<(pause+t));
336
  }
337
}
338
​
339
void patada (int tempo){
340
  for(int i=0;i<4;i++) servo[i].SetPosition(90);
341
  servo[0].SetPosition(115);
342
  servo[1].SetPosition(120);
343
  delay(tempo/4);
344
  servo[0].SetPosition(115);
345
  servo[1].SetPosition(70);
346
  delay(tempo/4);
347
  servo[0].SetPosition(100);
348
  servo[1].SetPosition(80);
349
  delay(tempo/4);
350
  servo[0].SetPosition(90);
351
  servo[1].SetPosition(90);
352
  delay(tempo/4);
353
}
354
​
355
void twist(int steps, int tempo){
356
  int move1[4] = {90,90,50,130};
357
  int move2[4] = {90,90,90,90};
358
​
359
    
360
  for(int x=0; x<steps; x++){ 
361
      pause=millis();
362
      moveNServos(tempo*0.1,move1);
363
      moveNServos(tempo*0.1,move2);
364
      while(millis()<(pause+tempo));
365
  }
366
}
367
​
368
void reverencia1 (int steps, int tempo){
369
  int move1[4] = {130,50,90,90};
370
  int move2[4] = {90,90,90,90};
371
    
372
  for(int x=0; x<steps; x++){ 
373
      pause=millis();
374
      for(int i=0;i<4;i++) servo[i].SetPosition(90);
375
      moveNServos(tempo*0.3,move1);
376
      delay(tempo*0.2);
377
      moveNServos(tempo*0.3,move2);
378
      while(millis()<(pause+tempo));
379
  }
380
}
381
​
382
void reverencia2 (int steps, int tempo){
383
  int move1[4] = {130,50,90,90};
384
  int move2[4] = {130,50,60,120};
385
  int move3[4] = {90,90,90,90};
386
​
387
    
388
  for(int x=0; x<steps; x++){ 
389
      pause=millis();
390
      for(int i=0;i<4;i++) servo[i].SetPosition(90);
391
      delay(tempo*0.2);
392
      moveNServos(tempo*0.05,move1);
393
      moveNServos(tempo*0.05,move2);
394
      moveNServos(tempo*0.05,move1);
395
      moveNServos(tempo*0.05,move2);
396
      delay(tempo*0.2);
397
      moveNServos(tempo*0.1,move3);
398
      while(millis()<(pause+tempo));
399
  }
400
}
401
​
402
void saludo(int steps, int tempo){
403
  int move1[4] = {60,60,90,90};
404
  int move2[4] = {120,60,90,90};
405
    
406
  for(int x=0; x<steps; x++){ 
407
      pause=millis();
408
      for(int i=0;i<4;i++) servo[i].SetPosition(90);
409
      moveNServos(tempo*0.25,move1);
410
      moveNServos(tempo*0.25,move2);
411
      moveNServos(tempo*0.25,move1);
412
      moveNServos(tempo*0.25,move2);
413
      while(millis()<(pause+tempo));
414
  }
415
}
416
​
417
void upDown(int steps, int tempo){
418
  int move1[4] = {50,130,90,90};
419
  int move2[4] = {90,90,90,90};
420
    
421
  for(int x=0; x<steps; x++){ 
422
      pause=millis();
423
      moveNServos(tempo*0.2,move1);
424
      delay(tempo*0.4);
425
      moveNServos(tempo*0.2,move2);
426
      while(millis()<(pause+tempo));
427
  }
428
}
429
​
430
void lateral_fuerte(boolean side, int tempo){
431
  
432
  for(int i=0;i<4;i++) servo[i].SetPosition(90);
433
  if (side) servo[0].SetPosition(40);
434
  else servo[1].SetPosition(140);
435
  delay(tempo/2);
436
  servo[0].SetPosition(90);
437
  servo[1].SetPosition(90);
438
  delay(tempo/2);
439
​
440
}
441
​
442
void run(int steps, int T){
443
    int A[4]= {10, 10, 10, 10};
444
    int O[4] = {0, 0, 0, 0};
445
    double phase_diff[4] = {DEG2RAD(0), DEG2RAD(0), DEG2RAD(90), DEG2RAD(90)}; 
446
    
447
    for(int i=0;i<steps;i++)oscillate(A,O, T, phase_diff);
448
}
449
​
450
void drunk (int tempo){
451
  
452
  pause=millis();
453
  
454
  int move1[] = {60,70,90,90};
455
  int move2[] = {110,120,90,90};
456
  int move3[] = {60,70,90,90};
457
  int move4[] = {110,120,90,90};
458
  int move5[] = {90,90,90,90};
459
  
460
  moveNServos(tempo*0.235,move1);
461
  moveNServos(tempo*0.235,move2);
462
  moveNServos(tempo*0.235,move3);
463
  moveNServos(tempo*0.235,move4);
464
  moveNServos(tempo*0.06,move5);
465
  while(millis()<(pause+tempo));
466
​
467
}
468
​
469
void kickLeft(int tempo){
470
  for(int i=0;i<4;i++) servo[i].SetPosition(90);
471
  delay(tempo);
472
  servo[0].SetPosition(50); //pie derecho
473
  servo[1].SetPosition(60); //pie izquiero
474
  delay(tempo);
475
  servo[0].SetPosition(80); //pie derecho
476
  servo[1].SetPosition(60); //pie izquiero
477
  delay(tempo/4);
478
  servo[0].SetPosition(40); //pie derecho
479
  servo[1].SetPosition(60); //pie izquiero
480
  delay(tempo/4);
481
  servo[0].SetPosition(80); //pie derecho
482
  servo[1].SetPosition(60); //pie izquiero
483
  delay(tempo/4);
484
  servo[0].SetPosition(40); //pie derecho
485
  servo[1].SetPosition(60); //pie izquiero
486
  delay(tempo/4);
487
  servo[0].SetPosition(80); //pie derecho
488
  servo[1].SetPosition(60); //pie izquiero
489
  delay(tempo);
490
}
491
​
492
void kickRight(int tempo){
493
for(int i=0;i<4;i++) servo[i].SetPosition(90);
494
  delay(tempo);
495
  servo[0].SetPosition(120); //pie derecho
496
  servo[1].SetPosition(130); //pie izquiero
497
  delay(tempo);
498
  servo[0].SetPosition(120); //pie derecho
499
  servo[1].SetPosition(100); //pie izquiero
500
  delay(tempo/4);
501
  servo[0].SetPosition(120); //pie derecho
502
  servo[1].SetPosition(140); //pie izquiero
503
  delay(tempo/4);
504
  servo[0].SetPosition(120); //pie derecho
505
  servo[1].SetPosition(80); //pie izquiero
506
  delay(tempo/4);
507
  servo[0].SetPosition(120); //pie derecho
508
  servo[1].SetPosition(140); //pie izquiero
509
  delay(tempo/4);
510
  servo[0].SetPosition(120); //pie derecho
511
  servo[1].SetPosition(100); //pie izquiero
512
  delay(tempo);
513
}
514
​
515
void walk(int steps, int T){
516
    int A[4]= {15, 15, 30, 30};
517
    int O[4] = {0, 0, 0, 0};
518
    double phase_diff[4] = {DEG2RAD(0), DEG2RAD(0), DEG2RAD(90), DEG2RAD(90)};
519
    
520
    for(int i=0;i<steps;i++)oscillate(A,O, T, phase_diff);
521
}
522
​
523
void backyard(int steps, int T){
524
    int A[4]= {15, 15, 30, 30};
525
    int O[4] = {0, 0, 0, 0};
526
    double phase_diff[4] = {DEG2RAD(0), DEG2RAD(0), DEG2RAD(-90), DEG2RAD(-90)}; 
527
    
528
    for(int i=0;i<steps;i++)oscillate(A,O, T, phase_diff);
529
}
530
​
531
void moonWalkRight(int steps, int T){
532
    int A[4]= {25, 25, 0, 0};
533
    int O[4] = {-15 ,15, 0, 0};
534
    double phase_diff[4] = {DEG2RAD(0), DEG2RAD(180 + 120), DEG2RAD(90), DEG2RAD(90)}; 
535
    
536
    for(int i=0;i<steps;i++)oscillate(A,O, T, phase_diff);
537
}
538
​
539
void moonWalkLeft(int steps, int T){
540
    int A[4]= {25, 25, 0, 0};
541
    int O[4] = {-15, 15, 0, 0};
542
    double phase_diff[4] = {DEG2RAD(0), DEG2RAD(180 - 120), DEG2RAD(90), DEG2RAD(90)}; 
543
    
544
    for(int i=0;i<steps;i++)oscillate(A,O, T, phase_diff);
545
}
546
​
547
void crusaito(int steps, int T){
548
    int A[4]= {25, 25, 30, 30};
549
    int O[4] = {- 15, 15, 0, 0};
550
    double phase_diff[4] = {DEG2RAD(0), DEG2RAD(180 + 120), DEG2RAD(90), DEG2RAD(90)}; 
551
    
552
    for(int i=0;i<steps;i++)oscillate(A,O, T, phase_diff);
553
}
554
​
555
void swing(int steps, int T){
556
    int A[4]= {25, 25, 0, 0};
557
    int O[4] = {-15, 15, 0, 0};
558
    double phase_diff[4] = {DEG2RAD(0), DEG2RAD(0), DEG2RAD(90), DEG2RAD(90)};
559
    
560
    for(int i=0;i<steps;i++)oscillate(A,O, T, phase_diff);
561
}
562
​
563
void flapping(int steps, int T){
564
    int A[4]= {15, 15, 8, 8};
565
    int O[4] = {-A[0], A[1], 0, 0};
566
    double phase_diff[4] = {DEG2RAD(0), DEG2RAD(180), DEG2RAD(90), DEG2RAD(-90)};
567
    
568
    for(int i=0;i<steps;i++)oscillate(A,O, T, phase_diff);
569
}
570
​
RENAMED
Code/Otto_smooth_criminal.ino
1
//----------------------------------------------------------------
2
//-- Otto Dance smooth criminal
3
//-- This code will make Otto dance play the by Michael Jackson song at the same time and see it in action
4
//-- April 2019: Designed to work with the basic Otto but could be compatible with PLUS or Humanoid or other biped robots
5
/******************************************************************************************************
6
  Make sure to have installed all libraries: https://wikifactory.com/+OttoDIY/otto-diy
7
  Otto DIY invests time and resources providing open source code and hardware, 
8
  please support by purchasing kits from (https://www.ottodiy.com)
9
  
10
  BSD license, all text above must be included in any redistribution
11
 *******************************************************************/
12
//-----------------------------------------------------------------
13
#include <Servo.h>
14
#include <Oscillator.h>
15
#include <EEPROM.h>
16
#define N_SERVOS 4
17
//-- Make sure the servos are in the right pin
18
/*                  -------- 
19
                   |  O  O  |
20
                   |--------|
21
  RIGHT LEG (YR) 3 |        | LEFT LEG 2 (YL)
22
                    -------- 
23
                    ||     ||
24
RIGHT FOOT (RR) 5 |---     ---| LEFT FOOT 4 (RL)  
25
*/
26
#define EEPROM_TRIM false 
27
// Activate to take callibration data from internal memory
28
#define TRIM_RR 7
29
#define TRIM_RL 4
30
#define TRIM_YR  4
31
#define TRIM_YL -7
32
//OTTO.setTrims(-7,-4,-4,7);
33
​
34
#define PIN_RR 5
35
#define PIN_RL 4
36
#define PIN_YR 3
37
#define PIN_YL 2
38
​
39
#define INTERVALTIME 10.0 
40
​
41
Oscillator servo[N_SERVOS];
42
​
43
void goingUp(int tempo);
44
void drunk (int tempo);
45
void noGravity(int tempo);
46
void kickLeft(int tempo);
47
void kickRight(int tempo);
48
void run(int steps, int T=500);
49
void walk(int steps, int T=1000);
50
void backyard(int steps, int T=3000);
51
void backyardSlow(int steps, int T=5000);
52
void turnLeft(int steps, int T=3000);
53
void turnRight(int steps, int T=3000);
54
void moonWalkLeft(int steps, int T=1000);
55
void moonWalkRight(int steps, int T=1000);
56
void crusaito(int steps, int T=1000);
57
void swing(int steps, int T=1000);
58
void upDown(int steps, int T=1000);
59
void flapping(int steps, int T=1000);
60
​
61
void setup()
62
{
63
  Serial.begin(19200);
64
  
65
  servo[0].attach(PIN_RR);
66
  servo[1].attach(PIN_RL);
67
  servo[2].attach(PIN_YR);
68
  servo[3].attach(PIN_YL);
69
  
70
  //EEPROM.write(0,TRIM_RR);
71
  //EEPROM.write(1,TRIM_RL);
72
  //EEPROM.write(2,TRIM_YR);
73
  //EEPROM.write(3,TRIM_YL);
74
  
75
  int trim;
76
  
77
  if(EEPROM_TRIM){
78
    for(int x=0;x<4;x++){
79
      trim=EEPROM.read(x);
80
      if(trim>128)trim=trim-256;
81
      Serial.print("TRIM ");
82
      Serial.print(x);
83
      Serial.print(" en ");
84
      Serial.println(trim);
85
      servo[x].SetTrim(trim);
86
    }
87
  }
88
  else{
89
    servo[0].SetTrim(TRIM_RR);
90
    servo[1].SetTrim(TRIM_RL);
91
    servo[2].SetTrim(TRIM_YR);
92
    servo[3].SetTrim(TRIM_YL);
93
  }
94
  
95
  for(int i=0;i<4;i++) servo[i].SetPosition(90);
96
}
97
​
98
// TEMPO: 121 BPM
99
int t=495;
100
double pause=0;
101
​
102
void loop()
103
{
104
 // if(Serial.available()){
105
  //  char init = Serial.read();
106
   // if (init=='X'){
107
   //   delay(4000); //3000 - 4500
108
   
109
dance();
110
​
111
​
112
//for(int i=0;i<4;i++) servo[i].SetPosition(90);
113
​
114
      
115
          for(int i=0;i<4;i++) servo[i].SetPosition(90);
116
   // }
117
 // }
118
}
119
​
120
void dance(){
121
  primera_parte();
122
  segunda_parte();
123
  moonWalkLeft(4,t*2);
124
  moonWalkRight(4,t*2);
125
  moonWalkLeft(4,t*2);
126
  moonWalkRight(4,t*2);
127
  primera_parte(); 
128
  crusaito(1,t*8);
129
  crusaito(1,t*7);
130
​
131
  for (int i=0; i<16; i++){
132
    flapping(1,t/4);
133
    delay(3*t/4);
134
  }
135
 
136
  moonWalkRight(4,t*2);
137
  moonWalkLeft(4,t*2);
138
  moonWalkRight(4,t*2);
139
  moonWalkLeft(4,t*2);
140
​
141
  drunk(t*4);
142
  drunk(t*4);
143
  drunk(t*4);
144
  drunk(t*4);
145
  kickLeft(t);
146
  kickRight(t);
147
  drunk(t*8);
148
  drunk(t*4);
149
  drunk(t/2);
150
  delay(t*4); 
151
​
152
  drunk(t/2);
153
​
154
  delay(t*4); 
155
  walk(2,t*2);
156
  backyard(2,t*2);
157
  goingUp(t*2);
158
  goingUp(t*1);
159
  noGravity(t*2);
160
  crusaito(1,t*2);
161
  crusaito(1,t*8);
162
  crusaito(1,t*2);
163
  crusaito(1,t*8);
164
  crusaito(1,t*2);
165
  crusaito(1,t*3);
166
​
167
  delay(t);
168
  primera_parte();
169
    for (int i=0; i<32; i++){
170
    flapping(1,t/2);
171
    delay(t/2);
172
  }
173
  
174
  for(int i=0;i<4;i++) servo[i].SetPosition(90);
175
}
176
​
177
​
178
​
179
​
180
////////////////////////////////////////////////////////////////////////////////////////
181
//////////////////////////////////FUNCIONES DE CONTROL//////////////////////////////////
182
////////////////////////////////////////////////////////////////////////////////////////
183
​
184
void oscillate(int A[N_SERVOS], int O[N_SERVOS], int T, double phase_diff[N_SERVOS]){
185
  for (int i=0; i<4; i++) {
186
    servo[i].SetO(O[i]);
187
    servo[i].SetA(A[i]);
188
    servo[i].SetT(T);
189
    servo[i].SetPh(phase_diff[i]);
190
  }
191
  double ref=millis();
192
   for (double x=ref; x<T+ref; x=millis()){
193
     for (int i=0; i<4; i++){
194
        servo[i].refresh();
195
     }
196
  }
197
}
198
​
199
unsigned long final_time;
200
unsigned long interval_time;
201
int oneTime;
202
int iteration;
203
float increment[N_SERVOS]; 
204
int oldPosition[]={90,90,90,90};
205
​
206
void moveNServos(int time, int  newPosition[]){
207
  for(int i=0;i<N_SERVOS;i++)   increment[i] = ((newPosition[i])-oldPosition[i])/(time/INTERVALTIME);
208
  
209
  final_time =  millis() + time; 
210
  
211
  iteration = 1; 
212
  while(millis() < final_time){ //Javi del futuro cambia esto  
213
      interval_time = millis()+INTERVALTIME;  
214
      
215
      oneTime=0;      
216
      while(millis()<interval_time){      
217
          if(oneTime<1){ 
218
              for(int i=0;i<N_SERVOS;i++){
219
                  servo[i].SetPosition(oldPosition[i] + (iteration * increment[i]));
220
              }         
221
              iteration++;
222
              oneTime++;
223
          }
224
      }     
225
  }   
226
​
227
  for(int i=0;i<N_SERVOS;i++){  
228
    oldPosition[i] = newPosition[i];
229
  }   
230
}
231
​
232
​
233
//////////////////////////////////////////////////////////////////////////////
234
////////////////////////////////PASOS DE BAILE////////////////////////////////
235
//////////////////////////////////////////////////////////////////////////////
236
​
237
void goingUp(int tempo){
238
  
239
      pause=millis();
240
      for(int i=0;i<4;i++) servo[i].SetPosition(90);
241
      delay(tempo);
242
      servo[0].SetPosition(80);
243
      servo[1].SetPosition(100);
244
      delay(tempo);
245
      servo[0].SetPosition(70);
246
      servo[1].SetPosition(110);
247
      delay(tempo);
248
      servo[0].SetPosition(60);
249
      servo[1].SetPosition(120);
250
      delay(tempo);
251
      servo[0].SetPosition(50);
252
      servo[1].SetPosition(130);
253
      delay(tempo);
254
      servo[0].SetPosition(40);
255
      servo[1].SetPosition(140);
256
      delay(tempo);
257
      servo[0].SetPosition(30);
258
      servo[1].SetPosition(150);
259
      delay(tempo);
260
      servo[0].SetPosition(20);
261
      servo[1].SetPosition(160);
262
      delay(tempo);
263
      
264
      while(millis()<pause+8*t);
265
​
266
}
267
​
268
void primera_parte(){
269
  
270
  int move1[4] = {60,120,90,90};
271
  int move2[4] = {90,90,90,90};
272
  int move3[4] = {40,140,90,90};
273
  
274
  for(int x=0; x<3; x++){
275
    for(int i=0; i<3; i++){
276
      lateral_fuerte(1,t/2);
277
      lateral_fuerte(0,t/4);
278
      lateral_fuerte(1,t/4);
279
      delay(t);
280
    }
281
  
282
    pause=millis();
283
    for(int i=0;i<4;i++) servo[i].SetPosition(90);
284
    moveNServos(t*0.4,move1);
285
    moveNServos(t*0.4,move2);
286
    while(millis()<(pause+t*2));
287
  }
288
  
289
  for(int i=0; i<2; i++){
290
    lateral_fuerte(1,t/2);
291
    lateral_fuerte(0,t/4);
292
    lateral_fuerte(1,t/4);
293
    delay(t);
294
  }
295
    
296
  pause=millis();
297
  for(int i=0;i<4;i++) servo[i].SetPosition(90);
298
  crusaito(1,t*1.4);
299
  moveNServos(t*1,move3);
300
  for(int i=0;i<4;i++) servo[i].SetPosition(90);
301
  while(millis()<(pause+t*4));
302
}
303
​
304
void segunda_parte(){
305
  
306
  int move1[4] = {90,90,80,100};
307
  int move2[4] = {90,90,100,80};
308
  int move3[4] = {90,90,80,100};
309
  int move4[4] = {90,90,100,80};
310
    
311
  int move5[4] = {40,140,80,100};
312
  int move6[4] = {40,140,100,80};
313
  int move7[4] = {90,90,80,100};
314
  int move8[4] = {90,90,100,80};
315
       
316
  int move9[4] = {40,140,80,100};
317
  int move10[4] = {40,140,100,80};
318
  int move11[4] = {90,90,80,100};
319
  int move12[4] = {90,90,100,80};
320
  
321
  for(int x=0; x<7; x++){ 
322
    for(int i=0; i<3; i++){
323
      pause=millis();
324
      moveNServos(t*0.15,move1);
325
      moveNServos(t*0.15,move2);
326
      moveNServos(t*0.15,move3);
327
      moveNServos(t*0.15,move4);
328
      while(millis()<(pause+t));
329
    }
330
    pause=millis();
331
    moveNServos(t*0.15,move5);
332
    moveNServos(t*0.15,move6);
333
    moveNServos(t*0.15,move7);
334
    moveNServos(t*0.15,move8);
335
    while(millis()<(pause+t));
336
  }
337
 
338
  for(int i=0; i<3; i++){
339
    pause=millis();
340
    moveNServos(t*0.15,move9);
341
    moveNServos(t*0.15,move10);
342
    moveNServos(t*0.15,move11);
343
    moveNServos(t*0.15,move12);
344
    while(millis()<(pause+t));
345
  }
346
}
347
​
348
void lateral_fuerte(boolean side, int tempo){
349
  
350
  for(int i=0;i<4;i++) servo[i].SetPosition(90);
351
  if (side) servo[0].SetPosition(40);
352
  else servo[1].SetPosition(140);
353
  delay(tempo/2);
354
  servo[0].SetPosition(90);
355
  servo[1].SetPosition(90);
356
  delay(tempo/2);
357
​
358
}
359
​
360
void drunk (int tempo){
361
  
362
  pause=millis();
363
  
364
  int move1[] = {60,70,90,90};
365
  int move2[] = {110,120,90,90};
366
  int move3[] = {60,70,90,90};
367
  int move4[] = {110,120,90,90};
368
  
369
  moveNServos(tempo*0.235,move1);
370
  moveNServos(tempo*0.235,move2);
371
  moveNServos(tempo*0.235,move3);
372
  moveNServos(tempo*0.235,move4);
373
  while(millis()<(pause+tempo));
374
​
375
}
376
​
377
​
378
void noGravity(int tempo){
379
  
380
  int move1[4] = {120,140,90,90};
381
  int move2[4] = {140,140,90,90};
382
  int move3[4] = {120,140,90,90};
383
  int move4[4] = {90,90,90,90};
384
  
385
  
386
  for(int i=0;i<4;i++) servo[i].SetPosition(90);
387
  for(int i=0;i<N_SERVOS;i++) oldPosition[i]=90;
388
  moveNServos(tempo*2,move1);
389
  moveNServos(tempo*2,move2);
390
  delay(tempo*2);
391
  moveNServos(tempo*2,move3);
392
  moveNServos(tempo*2,move4);
393
​
394
 
395
​
396
}
397
​
398
void kickLeft(int tempo){
399
  for(int i=0;i<4;i++) servo[i].SetPosition(90);
400
  delay(tempo);
401
  servo[0].SetPosition(50); //pie derecho
402
  servo[1].SetPosition(70); //pie izquiero
403
  delay(tempo);
404
  servo[0].SetPosition(80); //pie derecho
405
  servo[1].SetPosition(70); //pie izquiero
406
  delay(tempo/4);
407
  servo[0].SetPosition(30); //pie derecho
408
  servo[1].SetPosition(70); //pie izquiero
409
  delay(tempo/4);
410
  servo[0].SetPosition(80); //pie derecho
411
  servo[1].SetPosition(70); //pie izquiero
412
  delay(tempo/4);
413
  servo[0].SetPosition(30); //pie derecho
414
  servo[1].SetPosition(70); //pie izquiero
415
  delay(tempo/4);
416
  servo[0].SetPosition(80); //pie derecho
417
  servo[1].SetPosition(70); //pie izquiero
418
  delay(tempo);
419
}
420
​
421
void kickRight(int tempo){
422
for(int i=0;i<4;i++) servo[i].SetPosition(90);
423
  delay(tempo);
424
  servo[0].SetPosition(110); //pie derecho
425
  servo[1].SetPosition(130); //pie izquiero
426
  delay(tempo);
427
  servo[0].SetPosition(110); //pie derecho
428
  servo[1].SetPosition(100); //pie izquiero
429
  delay(tempo/4);
430
  servo[0].SetPosition(110); //pie derecho
431
  servo[1].SetPosition(150); //pie izquiero
432
  delay(tempo/4);
433
  servo[0].SetPosition(110); //pie derecho
434
  servo[1].SetPosition(80); //pie izquiero
435
  delay(tempo/4);
436
  servo[0].SetPosition(110); //pie derecho
437
  servo[1].SetPosition(150); //pie izquiero
438
  delay(tempo/4);
439
  servo[0].SetPosition(110); //pie derecho
440
  servo[1].SetPosition(100); //pie izquiero
441
  delay(tempo);
442
}
443
​
444
void walk(int steps, int T){
445
    int A[4]= {15, 15, 30, 30};
446
    int O[4] = {0, 0, 0, 0};
447
    double phase_diff[4] = {DEG2RAD(0), DEG2RAD(0), DEG2RAD(90), DEG2RAD(90)};
448
    
449
    for(int i=0;i<steps;i++)oscillate(A,O, T, phase_diff);
450
}
451
​
452
void run(int steps, int T){
453
    int A[4]= {10, 10, 10, 10};
454
    int O[4] = {0, 0, 0, 0};
455
    double phase_diff[4] = {DEG2RAD(0), DEG2RAD(0), DEG2RAD(90), DEG2RAD(90)}; 
456
    
457
    for(int i=0;i<steps;i++)oscillate(A,O, T, phase_diff);
458
}
459
​
460
void backyard(int steps, int T){
461
    int A[4]= {15, 15, 30, 30};
462
    int O[4] = {0, 0, 0, 0};
463
    double phase_diff[4] = {DEG2RAD(0), DEG2RAD(0), DEG2RAD(-90), DEG2RAD(-90)}; 
464
    
465
    for(int i=0;i<steps;i++)oscillate(A,O, T, phase_diff);
466
}
467
​
468
void backyardSlow(int steps, int T){
469
    int A[4]= {15, 15, 30, 30};
470
    int O[4] = {0, 0, 0, 0};
471
    double phase_diff[4] = {DEG2RAD(0), DEG2RAD(0), DEG2RAD(-90), DEG2RAD(-90)}; 
472
    
473
    for(int i=0;i<steps;i++)oscillate(A,O, T, phase_diff);
474
}
475
​
476
​
477
void turnLeft(int steps, int T){
478
    int A[4]= {20, 20, 10, 30};
479
    int O[4] = {0, 0, 0, 0};
480
    double phase_diff[4] = {DEG2RAD(0), DEG2RAD(0), DEG2RAD(90), DEG2RAD(90)}; 
481
    
482
    for(int i=0;i<steps;i++)oscillate(A,O, T, phase_diff);
483
}
484
​
485
void turnRight(int steps, int T){
486
    int A[4]= {20, 20, 30, 10};
487
    int O[4] = {0, 0, 0, 0};
488
    double phase_diff[4] = {DEG2RAD(0), DEG2RAD(0), DEG2RAD(90), DEG2RAD(90)}; 
489
    
490
    for(int i=0;i<steps;i++)oscillate(A,O, T, phase_diff);
491
}
492
​
493
void moonWalkRight(int steps, int T){
494
    int A[4]= {25, 25, 0, 0};
495
    int O[4] = {-15 ,15, 0, 0};
496
    double phase_diff[4] = {DEG2RAD(0), DEG2RAD(180 + 120), DEG2RAD(90), DEG2RAD(90)}; 
497
    
498
    for(int i=0;i<steps;i++)oscillate(A,O, T, phase_diff);
499
}
500
​
501
void moonWalkLeft(int steps, int T){
502
    int A[4]= {25, 25, 0, 0};
503
    int O[4] = {-15, 15, 0, 0};
504
    double phase_diff[4] = {DEG2RAD(0), DEG2RAD(180 - 120), DEG2RAD(90), DEG2RAD(90)}; 
505
    
506
    for(int i=0;i<steps;i++)oscillate(A,O, T, phase_diff);
507
}
508
​
509
void crusaito(int steps, int T){
510
    int A[4]= {25, 25, 30, 30};
511
    int O[4] = {- 15, 15, 0, 0};
512
    double phase_diff[4] = {DEG2RAD(0), DEG2RAD(180 + 120), DEG2RAD(90), DEG2RAD(90)}; 
513
    
514
    for(int i=0;i<steps;i++)oscillate(A,O, T, phase_diff);
515
}
516
​
517
void swing(int steps, int T){
518
    int A[4]= {25, 25, 0, 0};
519
    int O[4] = {-15, 15, 0, 0};
520
    double phase_diff[4] = {DEG2RAD(0), DEG2RAD(0), DEG2RAD(90), DEG2RAD(90)};
521
    
522
    for(int i=0;i<steps;i++)oscillate(A,O, T, phase_diff);
523
}
524
​
525
void upDown(int steps, int T){
526
    int A[4]= {25, 25, 0, 0};
527
    int O[4] = {-15, 15, 0, 0};
528
    double phase_diff[4] = {DEG2RAD(180), DEG2RAD(0), DEG2RAD(270), DEG2RAD(270)};
529
    
530
    for(int i=0;i<steps;i++)oscillate(A,O, T, phase_diff);
531
}
532
​
533
void flapping(int steps, int T){
534
    int A[4]= {15, 15, 8, 8};
535
    int O[4] = {-A[0], A[1], 0, 0};
536
    double phase_diff[4] = {DEG2RAD(0), DEG2RAD(180), DEG2RAD(90), DEG2RAD(-90)};
537
    
538
    for(int i=0;i<steps;i++)oscillate(A,O, T, phase_diff);
539
}
540
​
541
void test(int steps, int T){
542
    int A[4]= {15, 15, 8, 8};
543
    int O[4] = {-A[0] + 10, A[1] - 10, 0, 0};
544
    double phase_diff[4] = {DEG2RAD(0), DEG2RAD(180), DEG2RAD(90), DEG2RAD(-90)};
545
    
546
    for(int i=0;i<steps;i++)oscillate(A,O, T, phase_diff);
547
}
548
​
RENAMED
Code/Otto_smooth_criminal_US.ino
s, int T){
    int A[4]= {15, 15, 8, 8};
    int O[4] = {-A[0], A[1], 0, 0};
    double phase_diff[4] = {DEG2RAD(0), DEG2RAD(180), DEG2RAD(90), DEG2RAD(-90)};
    
    for(int i=0;i<steps;i++)oscillate(A,O, T, phase_diff);
}

void test(int steps, int T){
    int A[4]= {15, 15, 8, 8};
    int O[4] = {-A[0] + 10, A[1] - 10, 0, 0};
    double phase_diff[4] = {DEG2RAD(0), DEG2RAD(180), DEG2RAD(90), DEG2RAD(-90)};
    
    for(int i=0;i<steps;i++)oscillate(A,O, T, phase_diff);
1
//----------------------------------------------------------------
2
//-- Otto Dance smooth criminal with Ultrasound activation
3
//-- This code will make Otto dance only after detect an object with the ultrasound sensor play the by Michael Jackson song at the same time and see it in action
4
//-- April 2019: Designed to work with the basic Otto but could be compatible with PLUS or Humanoid or other biped robots
5
/******************************************************************************************************
6
  Make sure to have installed all libraries: https://wikifactory.com/+OttoDIY/otto-diy
7
  Otto DIY invests time and resources providing open source code and hardware, 
8
  please support by purchasing kits from (https://www.ottodiy.com)
9
 
10
  BSD license, all text above must be included in any redistribution
11
 *******************************************************************/
12
//-----------------------------------------------------------------
13
#include <Servo.h>
14
#include <Oscillator.h>
15
#include <EEPROM.h>
16
​
17
#define N_SERVOS 4
18
//-- First step: Configure the pins where the servos are attached
19
/*
20
         --------------- 
21
        |     O   O     |
22
        |---------------|
23
YR 3==> |               | <== YL 2
24
         --------------- 
25
            ||     ||
26
RR 5==>   -----   ------  <== RL 4
27
         |-----   ------|
28
*/
29
#define EEPROM_TRIM false 
30
// Activate to take callibration data from internal memory
31
#define TRIM_RR 7
32
#define TRIM_RL 4
33
#define TRIM_YR  4
34
#define TRIM_YL -7
35
//OTTO.setTrims(-7,-4,-4,7);
36
​
37
#define PIN_RR 5
38
#define PIN_RL 4
39
#define PIN_YR 3
40
#define PIN_YL 2
41
​
42
#define INTERVALTIME 10.0 
43
​
44
Oscillator servo[N_SERVOS];
45
​
46
/*
47
void goingUp(int tempo);
48
void drunk (int tempo);
49
void noGravity(int tempo);
50
void kickLeft(int tempo);
51
void kickRight(int tempo);
52
void run1(int steps, int T=500);
53
void walk(int steps, int T=1000);
54
void backyard(int steps, int T=3000);
55
void backyardSlow(int steps, int T=5000);
56
void turnLeft(int steps, int T=3000);
57
void turnRight(int steps, int T=3000);
58
void moonWalkLeft(int steps, int T=1000);
59
void moonWalkRight(int steps, int T=1000);
60
void crusaito(int steps, int T=1000);
61
void swing(int steps, int T=1000);
62
void upDown(int steps, int T=1000);
63
void flapping(int steps, int T=1000);
64
*/
65
​
66
#define ECHOPIN 9        // Pin to receive echo pulse
67
#define TRIGPIN 8        // Pin to send trigger pulse
68
​
69
  int trimu;
70
  int dansezpttine = 0;
71
​
72
void setup()
73
{
74
//  Serial.begin(19200);
75
  
76
  servo[0].attach(PIN_RR);
77
  servo[1].attach(PIN_RL);
78
  servo[2].attach(PIN_YR);
79
  servo[3].attach(PIN_YL);
80
  
81
  //EEPROM.write(0,TRIM_RR);
82
  //EEPROM.write(1,TRIM_RL);
83
  //EEPROM.write(2,TRIM_YR);
84
  //EEPROM.write(3,TRIM_YL);
85
  
86
​
87
  if(EEPROM_TRIM){
88
    for(int x=0;x<4;x++){
89
      trimu=EEPROM.read(x);
90
      if(trimu>128)trimu=trimu-256;
91
      Serial.print("TRIM ");
92
      Serial.print(x);
93
      Serial.print(" en ");
94
      Serial.println(trimu);
95
      servo[x].SetTrim(trimu);
96
    }
97
  }
98
  else{
99
    servo[0].SetTrim(TRIM_RR);
100
    servo[1].SetTrim(TRIM_RL);
101
    servo[2].SetTrim(TRIM_YR);
102
    servo[3].SetTrim(TRIM_YL);
103
  }
104
  
105
  for(int i=0;i<4;i++) servo[i].SetPosition(90);
106
  delay(500);
107
  for(int i=0;i<4;i++) servo[i].detach();
108
​
109
  pinMode(ECHOPIN, INPUT);
110
  pinMode(TRIGPIN, OUTPUT);
111
}
112
​
113
// TEMPO: 121 BPM
114
int t=495;
115
double pause=0;
116
​
117
void loop()
118
{
119
 // if(Serial.available()){
120
  //  char init = Serial.read();
121
   // if (init=='X'){
122
   //   delay(4000); //3000 - 4500
123
​
124
// Start Ranging
125
  digitalWrite(TRIGPIN, LOW);
126
  delayMicroseconds(2);
127
  digitalWrite(TRIGPIN, HIGH);
128
  delayMicroseconds(10);
129
  digitalWrite(TRIGPIN, LOW);
130
  // Compute distance
131
  float distance = pulseIn(ECHOPIN, HIGH);
132
  distance= distance/58;
133
  Serial.print(distance);
134
  Serial.println("cm");
135
 if ((distance >1) && (distance < 25))   
136
  {
137
  Serial.println ("Danceeeee !");
138
  dansezpttine = 1;  
139
  }
140
 
141
 
142
 if (dansezpttine == 1)
143
 {
144
  servo[0].attach(PIN_RR);
145
  servo[1].attach(PIN_RL);
146
  servo[2].attach(PIN_YR);
147
  servo[3].attach(PIN_YL);
148
​
149
  if(EEPROM_TRIM){
150
    for(int x=0;x<4;x++){
151
      trimu=EEPROM.read(x);
152
      if(trimu>128)trimu=trimu-256;
153
      Serial.print("TRIM ");
154
      Serial.print(x);
155
      Serial.print(" en ");
156
      Serial.println(trimu);
157
      servo[x].SetTrim(trimu);
158
    }
159
  }
160
  else{
161
    servo[0].SetTrim(TRIM_RR);
162
    servo[1].SetTrim(TRIM_RL);
163
    servo[2].SetTrim(TRIM_YR);
164
    servo[3].SetTrim(TRIM_YL);
165
  }
166
delay(100); 
167
 dance();
168
delay(500); 
169
 for(int i=0;i<4;i++) servo[i].SetPosition(90);
170
delay(500);
171
 for(int i=0;i<4;i++) servo[i].detach();
172
 dansezpttine = 0;
173
 }
174
delay(200);
175
​
176
//for(int i=0;i<4;i++) servo[i].SetPosition(90);
177
​
178
     
179
   // }
180
 // }
181
}
182
​
183
void dance(){
184
  primera_parte();
185
  segunda_parte();
186
  moonWalkLeft(4,t*2);
187
  moonWalkRight(4,t*2);
188
  moonWalkLeft(4,t*2);
189
  moonWalkRight(4,t*2);
190
  primera_parte(); 
191
  crusaito(1,t*8);
192
  crusaito(1,t*7);
193
​
194
  for (int i=0; i<16; i++){
195
    flapping(1,t/4);
196
    delay(3*t/4);
197
  }
198
​
199
  moonWalkRight(4,t*2);
200
  moonWalkLeft(4,t*2);
201
  moonWalkRight(4,t*2);
202
  moonWalkLeft(4,t*2);
203
​
204
  drunk(t*4);
205
  drunk(t*4);
206
  drunk(t*4);
207
  drunk(t*4);
208
  kickLeft(t);
209
  kickRight(t);
210
  drunk(t*8);
211
  drunk(t*4);
212
  drunk(t/2);
213
  delay(t*4); 
214
​
215
  drunk(t/2);
216
​
217
  delay(t*4); 
218
  walk(2,t*2);
219
  backyard(2,t*2);
220
  goingUp(t*2);
221
  goingUp(t*1);
222
  noGravity(t*2);
223
  crusaito(1,t*2);
224
  crusaito(1,t*8);
225
  crusaito(1,t*2);
226
  crusaito(1,t*8);
227
  crusaito(1,t*2);
228
  crusaito(1,t*3);
229
​
230
  delay(t);
231
  primera_parte();
232
    for (int i=0; i<32; i++){
233
    flapping(1,t/2);
234
    delay(t/2);
235
  }
236
  
237
  for(int i=0;i<4;i++) servo[i].SetPosition(90);
238
}
239
​
240
​
241
​
242
​
243
////////////////////////////////////////////////////////////////////////////////////////
244
//////////////////////////////////FUNCIONES DE CONTROL//////////////////////////////////
245
////////////////////////////////////////////////////////////////////////////////////////
246
​
247
void oscillate(int A[N_SERVOS], int O[N_SERVOS], int T, double phase_diff[N_SERVOS]){
248
  for (int i=0; i<4; i++) {
249
    servo[i].SetO(O[i]);
250
    servo[i].SetA(A[i]);
251
    servo[i].SetT(T);
252
    servo[i].SetPh(phase_diff[i]);
253
  }
254
  double ref=millis();
255
   for (double x=ref; x<T+ref; x=millis()){
256
     for (int i=0; i<4; i++){
257
        servo[i].refresh();
258
     }
259
  }
260
}
261
​
262
unsigned long final_time;
263
unsigned long interval_time;
264
int oneTime;
265
int iteration;
266
float increment[N_SERVOS]; 
267
int oldPosition[]={90,90,90,90};
268
​
269
void moveNServos(int time, int  newPosition[]){
270
  for(int i=0;i<N_SERVOS;i++)   increment[i] = ((newPosition[i])-oldPosition[i])/(time/INTERVALTIME);
271
  
272
  final_time =  millis() + time; 
273
  
274
  iteration = 1; 
275
  while(millis() < final_time){ //Javi del futuro cambia esto  
276
      interval_time = millis()+INTERVALTIME;  
277
      
278
      oneTime=0;      
279
      while(millis()<interval_time){      
280
          if(oneTime<1){ 
281
              for(int i=0;i<N_SERVOS;i++){
282
                  servo[i].SetPosition(oldPosition[i] + (iteration * increment[i]));
283
              }         
284
              iteration++;
285
              oneTime++;
286
          }
287
      }     
288
  }   
289
​
290
  for(int i=0;i<N_SERVOS;i++){  
291
    oldPosition[i] = newPosition[i];
292
  }   
293
}
294
​
295
​
296
//////////////////////////////////////////////////////////////////////////////
297
////////////////////////////////PASOS DE BAILE////////////////////////////////
298
//////////////////////////////////////////////////////////////////////////////
299
​
300
void goingUp(int tempo){
301
  
302
      pause=millis();
303
      for(int i=0;i<4;i++) servo[i].SetPosition(90);
304
      delay(tempo);
305
      servo[0].SetPosition(80);
306
      servo[1].SetPosition(100);
307
      delay(tempo);
308
      servo[0].SetPosition(70);
309
      servo[1].SetPosition(110);
310
      delay(tempo);
311
      servo[0].SetPosition(60);
312
      servo[1].SetPosition(120);
313
      delay(tempo);
314
      servo[0].SetPosition(50);
315
      servo[1].SetPosition(130);
316
      delay(tempo);
317
      servo[0].SetPosition(40);
318
      servo[1].SetPosition(140);
319
      delay(tempo);
320
      servo[0].SetPosition(30);
321
      servo[1].SetPosition(150);
322
      delay(tempo);
323
      servo[0].SetPosition(20);
324
      servo[1].SetPosition(160);
325
      delay(tempo);
326
      
327
      while(millis()<pause+8*t);
328
​
329
}
330
​
331
void primera_parte(){
332
  
333
  int move1[4] = {60,120,90,90};
334
  int move2[4] = {90,90,90,90};
335
  int move3[4] = {40,140,90,90};
336
  
337
  for(int x=0; x<3; x++){
338
    for(int i=0; i<3; i++){
339
      lateral_fuerte(1,t/2);
340
      lateral_fuerte(0,t/4);
341
      lateral_fuerte(1,t/4);
342
      delay(t);
343
    }
344
  
345
    pause=millis();
346
    for(int i=0;i<4;i++) servo[i].SetPosition(90);
347
    moveNServos(t*0.4,move1);
348
    moveNServos(t*0.4,move2);
349
    while(millis()<(pause+t*2));
350
  }
351
  
352
  for(int i=0; i<2; i++){
353
    lateral_fuerte(1,t/2);
354
    lateral_fuerte(0,t/4);
355
    lateral_fuerte(1,t/4);
356
    delay(t);
357
  }
358
    
359
  pause=millis();
360
  for(int i=0;i<4;i++) servo[i].SetPosition(90);
361
  crusaito(1,t*1.4);
362
  moveNServos(t*1,move3);
363
  for(int i=0;i<4;i++) servo[i].SetPosition(90);
364
  while(millis()<(pause+t*4));
365
}
366
​
367
void segunda_parte(){
368
  
369
  int move1[4] = {90,90,80,100};
370
  int move2[4] = {90,90,100,80};
371
  int move3[4] = {90,90,80,100};
372
  int move4[4] = {90,90,100,80};
373
    
374
  int move5[4] = {40,140,80,100};
375
  int move6[4] = {40,140,100,80};
376
  int move7[4] = {90,90,80,100};
377
  int move8[4] = {90,90,100,80};
378
       
379
  int move9[4] = {40,140,80,100};
380
  int move10[4] = {40,140,100,80};
381
  int move11[4] = {90,90,80,100};
382
  int move12[4] = {90,90,100,80};
383
  
384
  for(int x=0; x<7; x++){ 
385
    for(int i=0; i<3; i++){
386
      pause=millis();
387
      moveNServos(t*0.15,move1);
388
      moveNServos(t*0.15,move2);
389
      moveNServos(t*0.15,move3);
390
      moveNServos(t*0.15,move4);
391
      while(millis()<(pause+t));
392
    }
393
    pause=millis();
394
    moveNServos(t*0.15,move5);
395
    moveNServos(t*0.15,move6);
396
    moveNServos(t*0.15,move7);
397
    moveNServos(t*0.15,move8);
398
    while(millis()<(pause+t));
399
  }
400
 
401
  for(int i=0; i<3; i++){
402
    pause=millis();
403
    moveNServos(t*0.15,move9);
404
    moveNServos(t*0.15,move10);
405
    moveNServos(t*0.15,move11);
406
    moveNServos(t*0.15,move12);
407
    while(millis()<(pause+t));
408
  }
409
}
410
​
411
void lateral_fuerte(boolean side, int tempo){
412
  
413
  for(int i=0;i<4;i++) servo[i].SetPosition(90);
414
  if (side) servo[0].SetPosition(40);
415
  else servo[1].SetPosition(140);
416
  delay(tempo/2);
417
  servo[0].SetPosition(90);
418
  servo[1].SetPosition(90);
419
  delay(tempo/2);
420
​
421
}
422
​
423
void drunk (int tempo){
424
  
425
  pause=millis();
426
  
427
  int move1[] = {60,70,90,90};
428
  int move2[] = {110,120,90,90};
429
  int move3[] = {60,70,90,90};
430
  int move4[] = {110,120,90,90};
431
  
432
  moveNServos(tempo*0.235,move1);
433
  moveNServos(tempo*0.235,move2);
434
  moveNServos(tempo*0.235,move3);
435
  moveNServos(tempo*0.235,move4);
436
  while(millis()<(pause+tempo));
437
​
438
}
439
​
440
​
441
void noGravity(int tempo){
442
  
443
  int move1[4] = {120,140,90,90};
444
  int move2[4] = {140,140,90,90};
445
  int move3[4] = {120,140,90,90};
446
  int move4[4] = {90,90,90,90};
447
  
448
  
449
  for(int i=0;i<4;i++) servo[i].SetPosition(90);
450
  for(int i=0;i<N_SERVOS;i++) oldPosition[i]=90;
451
  moveNServos(tempo*2,move1);
452
  moveNServos(tempo*2,move2);
453
  delay(tempo*2);
454
  moveNServos(tempo*2,move3);
455
  moveNServos(tempo*2,move4);
456
​
457
 
458
​
459
}
460
​
461
void kickLeft(int tempo){
462
  for(int i=0;i<4;i++) servo[i].SetPosition(90);
463
  delay(tempo);
464
  servo[0].SetPosition(50); //pie derecho
465
  servo[1].SetPosition(70); //pie izquiero
466
  delay(tempo);
467
  servo[0].SetPosition(80); //pie derecho
468
  servo[1].SetPosition(70); //pie izquiero
469
  delay(tempo/4);
470
  servo[0].SetPosition(30); //pie derecho
471
  servo[1].SetPosition(70); //pie izquiero
472
  delay(tempo/4);
473
  servo[0].SetPosition(80); //pie derecho
474
  servo[1].SetPosition(70); //pie izquiero
475
  delay(tempo/4);
476
  servo[0].SetPosition(30); //pie derecho
477
  servo[1].SetPosition(70); //pie izquiero
478
  delay(tempo/4);
479
  servo[0].SetPosition(80); //pie derecho
480
  servo[1].SetPosition(70); //pie izquiero
481
  delay(tempo);
482
}
483
​
484
void kickRight(int tempo){
485
for(int i=0;i<4;i++) servo[i].SetPosition(90);
486
  delay(tempo);
487
  servo[0].SetPosition(110); //pie derecho
488
  servo[1].SetPosition(130); //pie izquiero
489
  delay(tempo);
490
  servo[0].SetPosition(110); //pie derecho
491
  servo[1].SetPosition(100); //pie izquiero
492
  delay(tempo/4);
493
  servo[0].SetPosition(110); //pie derecho
494
  servo[1].SetPosition(150); //pie izquiero
495
  delay(tempo/4);
496
  servo[0].SetPosition(110); //pie derecho
497
  servo[1].SetPosition(80); //pie izquiero
498
  delay(tempo/4);
499
  servo[0].SetPosition(110); //pie derecho
500
  servo[1].SetPosition(150); //pie izquiero
501
  delay(tempo/4);
502
  servo[0].SetPosition(110); //pie derecho
503
  servo[1].SetPosition(100); //pie izquiero
504
  delay(tempo);
505
}
506
​
507
void walk(int steps, int T){
508
    int A[4]= {15, 15, 30, 30};
509
    int O[4] = {0, 0, 0, 0};
510
    double phase_diff[4] = {DEG2RAD(0), DEG2RAD(0), DEG2RAD(90), DEG2RAD(90)};
511
    
512
    for(int i=0;i<steps;i++)oscillate(A,O, T, phase_diff);
513
}
514
​
515
void run1(int steps, int T){
516
    int A[4]= {10, 10, 10, 10};
517
    int O[4] = {0, 0, 0, 0};
518
    double phase_diff[4] = {DEG2RAD(0), DEG2RAD(0), DEG2RAD(90), DEG2RAD(90)}; 
519
    
520
    for(int i=0;i<steps;i++)oscillate(A,O, T, phase_diff);
521
}
522
​
523
void backyard(int steps, int T){
524
    int A[4]= {15, 15, 30, 30};
525
    int O[4] = {0, 0, 0, 0};
526
    double phase_diff[4] = {DEG2RAD(0), DEG2RAD(0), DEG2RAD(-90), DEG2RAD(-90)}; 
527
    
528
    for(int i=0;i<steps;i++)oscillate(A,O, T, phase_diff);
529
}
530
​
531
void backyardSlow(int steps, int T){
532
    int A[4]= {15, 15, 30, 30};
533
    int O[4] = {0, 0, 0, 0};
534
    double phase_diff[4] = {DEG2RAD(0), DEG2RAD(0), DEG2RAD(-90), DEG2RAD(-90)}; 
535
    
536
    for(int i=0;i<steps;i++)oscillate(A,O, T, phase_diff);
537
}
538
​
539
​
540
void turnLeft(int steps, int T){
541
    int A[4]= {20, 20, 10, 30};
542
    int O[4] = {0, 0, 0, 0};
543
    double phase_diff[4] = {DEG2RAD(0), DEG2RAD(0), DEG2RAD(90), DEG2RAD(90)}; 
544
    
545
    for(int i=0;i<steps;i++)oscillate(A,O, T, phase_diff);
546
}
547
​
548
void turnRight(int steps, int T){
549
    int A[4]= {20, 20, 30, 10};
550
    int O[4] = {0, 0, 0, 0};
551
    double phase_diff[4] = {DEG2RAD(0), DEG2RAD(0), DEG2RAD(90), DEG2RAD(90)}; 
552
    
553
    for(int i=0;i<steps;i++)oscillate(A,O, T, phase_diff);
554
}
555
​
556
void moonWalkRight(int steps, int T){
557
    int A[4]= {25, 25, 0, 0};
558
    int O[4] = {-15 ,15, 0, 0};
559
    double phase_diff[4] = {DEG2RAD(0), DEG2RAD(180 + 120), DEG2RAD(90), DEG2RAD(90)}; 
560
    
561
    for(int i=0;i<steps;i++)oscillate(A,O, T, phase_diff);
562
}
563
​
564
void moonWalkLeft(int steps, int T){
565
    int A[4]= {25, 25, 0, 0};
566
    int O[4] = {-15, 15, 0, 0};
567
    double phase_diff[4] = {DEG2RAD(0), DEG2RAD(180 - 120), DEG2RAD(90), DEG2RAD(90)}; 
568
    
569
    for(int i=0;i<steps;i++)oscillate(A,O, T, phase_diff);
570
}
571
​
572
void crusaito(int steps, int T){
573
    int A[4]= {25, 25, 30, 30};
574
    int O[4] = {- 15, 15, 0, 0};
575
    double phase_diff[4] = {DEG2RAD(0), DEG2RAD(180 + 120), DEG2RAD(90), DEG2RAD(90)}; 
576
    
577
    for(int i=0;i<steps;i++)oscillate(A,O, T, phase_diff);
578
}
579
​
580
void swing(int steps, int T){
581
    int A[4]= {25, 25, 0, 0};
582
    int O[4] = {-15, 15, 0, 0};
583
    double phase_diff[4] = {DEG2RAD(0), DEG2RAD(0), DEG2RAD(90), DEG2RAD(90)};
584
    
585
    for(int i=0;i<steps;i++)oscillate(A,O, T, phase_diff);
586
}
587
​
588
void upDown(int steps, int T){
589
    int A[4]= {25, 25, 0, 0};
590
    int O[4] = {-15, 15, 0, 0};
591
    double phase_diff[4] = {DEG2RAD(180), DEG2RAD(0), DEG2RAD(270), DEG2RAD(270)};
592
    
593
    for(int i=0;i<steps;i++)oscillate(A,O, T, phase_diff);
594
}
595
​
596
void flapping(int steps, int T){
597
    int A[4]= {15, 15, 8, 8};
598
    int O[4] = {-A[0], A[1], 0, 0};
599
    double phase_diff[4] = {DEG2RAD(0), DEG2RAD(180), DEG2RAD(90), DEG2RAD(-90)};
600
    
601
    for(int i=0;i<steps;i++)oscillate(A,O, T, phase_diff);
602
}
603
​
604
void test(int steps, int T){
605
    int A[4]= {15, 15, 8, 8};
606
    int O[4] = {-A[0] + 10, A[1] - 10, 0, 0};
607
    double phase_diff[4] = {DEG2RAD(0), DEG2RAD(180), DEG2RAD(90), DEG2RAD(-90)};
608
    
609
    for(int i=0;i<steps;i++)oscillate(A,O, T, phase_diff);
610
}
611
​
RENAMED
Code/README.md
1
# Software
2
​
3
Manual installation of Libraries
4
​
5
•
6
​
7
When you want to add a library manually, you need to download it as a ZIP file, expand it and put in the proper directory. The ZIP file contains all you need, including usage examples if the author has provided them. The library manager is designed to install this ZIP file automatically as explained in the former chapter, but there are cases where you may want to perform the installation process manually and put the library in the libraries folder of your sketchbook by yourself.
8
​
9
You can find or change the location of your sketchbook folder at File &gt; Preferences &gt; Sketchbook location.
10
​
11
•
12
​
13
more details here: https://www.arduino.cc/en/guide/libraries•
RENAMED
Fichiers supprimés (7)

Software/Drivers/CH340 Windows .EXE
REMOVED
Software/Drivers/CH340 Windows Manual installation.zip
REMOVED
Software/Drivers/CH340_MAC.ZIP
REMOVED
Software/Drivers/CH341SER.ZIP
REMOVED
Software/Drivers/CH341SER_LINUX.ZIP
REMOVED
Software/Drivers/CH341SER_MAC.ZIP
REMOVED
Software/Drivers/CH341SER_MAC_1.3.ZIP
REMOVED
Se connecter / s'inscrire commenter sur ce Contribution.

Fichiers mis à jour (1)

README.md
Fichiers renommés (18)

Code/Otto_Alarm.ino
Code/Otto_Footalign.ino
Code/Otto_MarioBros.ino
Code/Otto_Mblock_Scratch_Serial.ino
Code/Otto_SW.ino
Code/Otto_allmoves.ino
Code/Otto_avoid.ino
Code/Otto_avoid_TRIMS.ino
Code/Otto_avoid_mhs.ino
Code/Otto_easycalibration.ino
Code/Otto_happybirthday.ino
Code/Otto_jingle.ino
Code/Otto_retrieve.ino
Code/Otto_run.ino
Code/Otto_singleladies.ino
Code/Otto_smooth_criminal.ino
Code/Otto_smooth_criminal_US.ino
Code/README.md
Fichiers supprimés (7)

Software/Drivers/CH340 Windows .EXE
Software/Drivers/CH340 Windows Manual installation.zip
Software/Drivers/CH340_MAC.ZIP
Software/Drivers/CH341SER.ZIP
Software/Drivers/CH341SER_LINUX.ZIP
Software/Drivers/CH341SER_MAC.ZIP
Software/Drivers/CH341SER_MAC_1.3.ZIP
© 2022 Wikifactory Ltd.
Page principalÀ propos deConfidentialitéCookiestermes
